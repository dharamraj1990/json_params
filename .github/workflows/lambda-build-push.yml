name: Build, Push and Deploy Lambda Functions

on:
  push:
    branches:
      - develop
      - release
    paths:
      - 'lambda-functions/**'
  pull_request:
    branches:
      - develop
      - release
    paths:
      - 'lambda-functions/**'

env:
  AWS_REGION: us-east-1  # Change to your AWS region
  ECR_REPOSITORY: lambda-function-1-repo  # Single ECR repository for all Lambda functions
  # AWS Account Numbers for each environment (can be overridden via secrets)
  AWS_ACCOUNT_DEV: ${{ secrets.AWS_ACCOUNT_DEV || '533269020590' }}
  AWS_ACCOUNT_STAGING: ${{ secrets.AWS_ACCOUNT_STAGING || '533269020590' }}
  AWS_ACCOUNT_PROD: ${{ secrets.AWS_ACCOUNT_PROD || '533269020590' }}
  OIDC_ROLE_NAME: oidc-github-action  # IAM role name for OIDC authentication

jobs:
  determine-environment:
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.env.outputs.environment }}
      should-deploy-dev: ${{ steps.env.outputs.should-deploy-dev }}
      should-deploy-staging: ${{ steps.env.outputs.should-deploy-staging }}
      should-deploy-prod: ${{ steps.env.outputs.should-deploy-prod }}
      branch-type: ${{ steps.env.outputs.branch-type }}
    steps:
      - name: Determine environment from branch
        id: env
        run: |
          BRANCH_NAME="${{ github.ref_name }}"
          BRANCH_REF="${{ github.ref }}"
          IS_PR="${{ github.event_name == 'pull_request' }}"
          
          echo "Branch: $BRANCH_NAME"
          echo "Ref: $BRANCH_REF"
          echo "Is PR: $IS_PR"
          
          # Initialize defaults
          ENVIRONMENT="none"
          DEPLOY_DEV="false"
          DEPLOY_STAGING="false"
          DEPLOY_PROD="false"
          BRANCH_TYPE="unknown"
          
          # Pull requests: Build only, no deployment
          if [ "$IS_PR" == "true" ]; then
            ENVIRONMENT="pr"
            BRANCH_TYPE="pull_request"
            echo "üîç Pull Request detected - Build only, no deployment"
          
          # Develop branch: Dev deployment (automatic)
          elif [ "$BRANCH_REF" == "refs/heads/develop" ]; then
            ENVIRONMENT="dev"
            DEPLOY_DEV="true"
            BRANCH_TYPE="develop"
            echo "üíª Develop branch detected - Dev deployment (automatic)"
          
          # Release branch: Staging and Production deployment (with approval)
          elif [ "$BRANCH_REF" == "refs/heads/release" ]; then
            ENVIRONMENT="release"
            DEPLOY_STAGING="true"
            DEPLOY_PROD="true"
            BRANCH_TYPE="release"
            echo "üöÄ Release branch detected - Staging and Production deployment (with approval)"
          
          # Unknown branch: Build only
          else
            ENVIRONMENT="unknown"
            BRANCH_TYPE="other"
            echo "‚ùì Unknown branch type - Build only, no deployment"
          fi
          
          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
          echo "should-deploy-dev=$DEPLOY_DEV" >> $GITHUB_OUTPUT
          echo "should-deploy-staging=$DEPLOY_STAGING" >> $GITHUB_OUTPUT
          echo "should-deploy-prod=$DEPLOY_PROD" >> $GITHUB_OUTPUT
          echo "branch-type=$BRANCH_TYPE" >> $GITHUB_OUTPUT
          
          echo "üìä Deployment Summary:"
          echo "  Environment: $ENVIRONMENT"
          echo "  Deploy to Dev: $DEPLOY_DEV"
          echo "  Deploy to Staging: $DEPLOY_STAGING"
          echo "  Deploy to Production: $DEPLOY_PROD"
          echo "  Branch Type: $BRANCH_TYPE"

  detect-changes:
    needs: determine-environment
    runs-on: ubuntu-latest
    outputs:
      folders: ${{ steps.changes.outputs.folders }}
      folders-json: ${{ steps.changes.outputs.folders-json }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2  # Need depth 2 to compare with previous commit

      - name: Install jq
        run: |
          sudo apt-get update
          sudo apt-get install -y jq

      - name: Detect changed folders
        id: changes
        run: |
          # Get list of changed files
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            # For PRs, compare with base branch
            BASE_SHA="${{ github.event.pull_request.base.sha }}"
            HEAD_SHA="${{ github.sha }}"
          else
            # For pushes, compare with previous commit
            BASE_SHA="${{ github.event.before }}"
            HEAD_SHA="${{ github.sha }}"
          fi

          echo "BASE_SHA: $BASE_SHA"
          echo "HEAD_SHA: $HEAD_SHA"
          echo "Event: ${{ github.event_name }}"

          # Get changed files and extract unique folder names
          if [ -z "$BASE_SHA" ] || [ "$BASE_SHA" == "$HEAD_SHA" ] || [ "$BASE_SHA" == "0000000000000000000000000000000000000000" ]; then
            echo "No previous commit found or initial commit, checking all lambda function folders"
            # Get all folders in lambda-functions directory
            if [ -d "lambda-functions" ]; then
              CHANGED_FOLDERS=$(ls -d lambda-functions/*/ 2>/dev/null | xargs -n1 basename | sort)
            else
              CHANGED_FOLDERS=""
            fi
          else
            # Get changed files and extract unique folder names
            # Try multiple methods to get changed files
            if git rev-parse --verify "$BASE_SHA" >/dev/null 2>&1; then
              CHANGED_FILES=$(git diff --name-only $BASE_SHA $HEAD_SHA 2>/dev/null || echo "")
            else
              # If BASE_SHA doesn't exist, compare with HEAD~1
              CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD 2>/dev/null || echo "")
            fi
            
            echo "Changed files:"
            echo "$CHANGED_FILES"
            
            # Extract unique folder names from lambda-functions directory
            if [ -n "$CHANGED_FILES" ]; then
              CHANGED_FOLDERS=$(echo "$CHANGED_FILES" | grep "^lambda-functions/" | cut -d'/' -f2 | sort -u | tr '\n' ' ' | xargs)
            else
              CHANGED_FOLDERS=""
            fi
          fi

          echo "Detected folders: $CHANGED_FOLDERS"

          # Filter to only include folders that exist and build JSON array
          FOLDER_ARRAY=()
          if [ -n "$CHANGED_FOLDERS" ]; then
            for folder in $CHANGED_FOLDERS; do
              folder=$(echo "$folder" | xargs)  # Trim whitespace
              if [ -n "$folder" ] && [ -d "lambda-functions/$folder" ]; then
                FOLDER_ARRAY+=("$folder")
                echo "Added folder: $folder"
              fi
            done
          fi

          echo "Final folder array size: ${#FOLDER_ARRAY[@]}"

          if [ ${#FOLDER_ARRAY[@]} -eq 0 ]; then
            echo "No lambda function folders changed"
            echo "folders=" >> $GITHUB_OUTPUT
            {
              echo "folders-json<<EOF"
              echo "[]"
              echo "EOF"
            } >> $GITHUB_OUTPUT
          else
            # Create space-separated string for folders output
            EXISTING_FOLDERS=$(IFS=' '; echo "${FOLDER_ARRAY[*]}")
            echo "Changed folders: $EXISTING_FOLDERS"
            echo "folders=$EXISTING_FOLDERS" >> $GITHUB_OUTPUT
            
            # Convert to JSON array properly - ensure compact JSON without extra whitespace
            # Use jq -c to get compact JSON (single line, no extra whitespace)
            JSON_FOLDERS=$(printf '%s\n' "${FOLDER_ARRAY[@]}" | jq -R . | jq -s . | jq -c .)
            # Remove any trailing newlines and ensure it's truly a single line
            JSON_FOLDERS=$(echo -n "$JSON_FOLDERS" | tr -d '\n\r')
            # Validate JSON is valid
            if ! echo "$JSON_FOLDERS" | jq empty > /dev/null 2>&1; then
              echo "ERROR: Generated invalid JSON: $JSON_FOLDERS"
              exit 1
            fi
            # Output JSON directly (compact JSON should work without delimiter syntax)
            echo "folders-json=$JSON_FOLDERS" >> $GITHUB_OUTPUT
            echo "JSON output (compact): $JSON_FOLDERS"
          fi

      - name: Output changed folders
        run: |
          echo "=== Change Detection Results ==="
          echo "Step outputs:"
          echo "  folders: '${{ steps.changes.outputs.folders }}'"
          echo "  folders-json: '${{ steps.changes.outputs.folders-json }}'"
          echo ""
          echo "Job outputs (for next job):"
          echo "  folders: '${{ needs.detect-changes.outputs.folders }}'"
          echo "  folders-json: '${{ needs.detect-changes.outputs.folders-json }}'"
          echo ""
          if [ -z "${{ steps.changes.outputs.folders }}" ]; then
            echo "‚ö†Ô∏è  WARNING: Folders output is empty - build job will be skipped"
          else
            echo "‚úÖ Folders detected: ${{ steps.changes.outputs.folders }}"
            echo "‚úÖ JSON: ${{ steps.changes.outputs.folders-json }}"
            echo "‚úÖ Build job should run"
          fi

  build-and-push:
    needs: [determine-environment, detect-changes]
    # Build on all branches (including PRs and feature branches)
    if: needs.detect-changes.outputs.folders != '' && needs.detect-changes.outputs.folders-json != '' && needs.detect-changes.outputs.folders-json != '[]'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        folder: ${{ fromJson(needs.detect-changes.outputs.folders-json) }}
      fail-fast: false  # Continue building other images even if one fails
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ env.AWS_ACCOUNT_DEV }}:role/${{ env.OIDC_ROLE_NAME }}
          role-session-name: GitHubActions-Build-${{ github.run_id }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set ECR repository and image tags
        id: ecr-config
        run: |
          # Use single ECR repository for all Lambda functions
          ECR_REPO="${{ env.ECR_REPOSITORY }}"
          
          # Image will be tagged with Lambda function name
          # Format: <ecr-repo>:<lambda-function-name>-<commit-sha>
          # Example: lambda-functions-repo:lambda-function-1-abc123
          LAMBDA_NAME="${{ matrix.folder }}"
          
          echo "ECR Repository: $ECR_REPO"
          echo "Lambda Function: $LAMBDA_NAME"
          echo "ecr-repo=$ECR_REPO" >> $GITHUB_OUTPUT
          echo "lambda-name=$LAMBDA_NAME" >> $GITHUB_OUTPUT
          
          # Construct full ECR URI
          FULL_ECR_URI="${{ steps.login-ecr.outputs.registry }}/$ECR_REPO"
          echo "ecr-uri=$FULL_ECR_URI" >> $GITHUB_OUTPUT

      - name: Set image tag
        id: image-tag
        run: |
          # Tag image with Lambda function name and commit SHA
          # Format: <lambda-function-name>-<commit-sha>
          # Example: lambda-function-1-abc123def456
          LAMBDA_NAME="${{ steps.ecr-config.outputs.lambda-name }}"
          COMMIT_SHA="${{ github.sha }}"
          
          IMAGE_TAG="${LAMBDA_NAME}-${COMMIT_SHA}"
          
          echo "tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "Image tag: $IMAGE_TAG"

      - name: Build Docker image
        working-directory: lambda-functions/${{ matrix.folder }}
        run: |
          echo "Building Docker image for lambda function: ${{ matrix.folder }}"
          docker build -t ${{ steps.ecr-config.outputs.ecr-uri }}:${{ steps.image-tag.outputs.tag }} .
          
          echo "Image built successfully with tag: ${{ steps.image-tag.outputs.tag }}"

      - name: Push Docker image to ECR
        run: |
          echo "Pushing image to ECR: ${{ steps.ecr-config.outputs.ecr-uri }}"
          
          # Push with single tag (Lambda name + commit SHA)
          docker push ${{ steps.ecr-config.outputs.ecr-uri }}:${{ steps.image-tag.outputs.tag }}
          
          echo "Image pushed successfully"
          echo "Image URI: ${{ steps.ecr-config.outputs.ecr-uri }}:${{ steps.image-tag.outputs.tag }}"

      - name: Output image details
        run: |
          echo "‚úÖ Successfully built and pushed image for: ${{ matrix.folder }}"
          echo "üì¶ ECR Repository: ${{ steps.ecr-config.outputs.ecr-uri }}"
          echo "üè∑Ô∏è  Tag: ${{ steps.image-tag.outputs.tag }}"
          echo "Image URI: ${{ steps.ecr-config.outputs.ecr-uri }}:${{ steps.image-tag.outputs.tag }}"

  deploy-dev:
    needs: [determine-environment, detect-changes, build-and-push]
    # Deploy to dev based on branch strategy
    if: success() && needs.detect-changes.outputs.folders != '' && needs.determine-environment.outputs.should-deploy-dev == 'true'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        folder: ${{ fromJson(needs.detect-changes.outputs.folders-json) }}
      fail-fast: false
    environment:
      name: dev
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ env.AWS_ACCOUNT_DEV }}:role/${{ env.OIDC_ROLE_NAME }}
          role-session-name: GitHubActions-Dev-${{ github.run_id }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Get image URI
        id: image-uri
        run: |
          IMAGE_TAG="${{ matrix.folder }}-${{ github.sha }}"
          IMAGE_URI="${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${IMAGE_TAG}"
          echo "image-uri=${IMAGE_URI}" >> $GITHUB_OUTPUT
          echo "Image URI: ${IMAGE_URI}"

      - name: Determine Lambda Function Name
        id: lambda-name
        run: |
          # Extract number from folder name (e.g., lambda-function-1 -> 1)
          FOLDER_NAME="${{ matrix.folder }}"
          LAMBDA_NUMBER=$(echo "$FOLDER_NAME" | sed 's/lambda-function-//')
          
          # Use full region name (e.g., us-east-1)
          REGION_FULL="${{ env.AWS_REGION }}"
          
          # Construct Lambda function name: dev-us-east-1-lambda-1
          LAMBDA_NAME="dev-${REGION_FULL}-lambda-${LAMBDA_NUMBER}"
          
          echo "lambda-name=${LAMBDA_NAME}" >> $GITHUB_OUTPUT
          echo "folder-name=${FOLDER_NAME}" >> $GITHUB_OUTPUT
          echo "lambda-number=${LAMBDA_NUMBER}" >> $GITHUB_OUTPUT
          
          echo "üì¶ Folder: $FOLDER_NAME"
          echo "üî¢ Lambda Number: $LAMBDA_NUMBER"
          echo "üåç Region: ${{ env.AWS_REGION }}"
          echo "üè∑Ô∏è  Actual Lambda Function Name: $LAMBDA_NAME"
          echo "üí≥ AWS Account: ${{ env.AWS_ACCOUNT_DEV }}"

      - name: Deploy ${{ steps.lambda-name.outputs.lambda-name }} to Dev
        run: |
          LAMBDA_NAME="${{ steps.lambda-name.outputs.lambda-name }}"
          IMAGE_URI="${{ steps.image-uri.outputs.image-uri }}"
          
          echo "üöÄ Deploying $LAMBDA_NAME to dev environment..."
          
          # List available Lambda functions for debugging
          echo "üìã Listing available Lambda functions in region ${{ env.AWS_REGION }}..."
          aws lambda list-functions \
            --region ${{ env.AWS_REGION }} \
            --query 'Functions[].FunctionName' \
            --output table || echo "‚ö†Ô∏è Could not list functions (may be a permissions issue)"
          
          # Check if function exists
          echo "üîç Checking if function $LAMBDA_NAME exists..."
          FUNCTION_EXISTS=$(aws lambda get-function \
            --function-name "$LAMBDA_NAME" \
            --region ${{ env.AWS_REGION }} \
            --query 'Configuration.FunctionName' \
            --output text 2>/dev/null || echo "")
          
          if [ -z "$FUNCTION_EXISTS" ]; then
            echo "‚ùå ERROR: Function $LAMBDA_NAME not found!"
            echo "üìã Available functions matching pattern:"
            aws lambda list-functions \
              --region ${{ env.AWS_REGION }} \
              --query "Functions[?contains(FunctionName, 'dev') || contains(FunctionName, 'lambda') || contains(FunctionName, '$LAMBDA_NUMBER')].FunctionName" \
              --output table || echo "Could not list functions"
            echo ""
            echo "üí° Possible issues:"
            echo "   1. Function name doesn't match expected pattern: $LAMBDA_NAME"
            echo "   2. Function exists in a different AWS account"
            echo "   3. Function exists in a different region"
            echo "   4. OIDC role doesn't have permissions to access the function"
            exit 1
          fi
          
          echo "‚úÖ Function found: $FUNCTION_EXISTS"
          
          # Wait for any in-progress updates to complete
          echo "Checking for in-progress updates..."
          MAX_WAIT=300  # 5 minutes max wait
          WAIT_TIME=0
          while [ $WAIT_TIME -lt $MAX_WAIT ]; do
            STATE=$(aws lambda get-function-configuration \
              --function-name "$LAMBDA_NAME" \
              --region ${{ env.AWS_REGION }} \
              --query 'State' --output text 2>/dev/null || echo "Active")
            if [ "$STATE" == "Active" ] || [ "$STATE" == "Inactive" ]; then
              echo "Function is ready for update (State: $STATE)"
              break
            else
              echo "Function state: $STATE, waiting 10 seconds..."
              sleep 10
              WAIT_TIME=$((WAIT_TIME + 10))
            fi
          done
          
          # Update existing Lambda function (functions already exist)
          echo "Updating Lambda function: $LAMBDA_NAME"
          MAX_RETRIES=3
          RETRY_COUNT=0
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            if aws lambda update-function-code \
              --function-name "$LAMBDA_NAME" \
              --image-uri "$IMAGE_URI" \
              --region ${{ env.AWS_REGION }} 2>&1; then
              echo "Update initiated successfully"
              break
            else
              ERROR_OUTPUT=$(aws lambda update-function-code \
                --function-name "$LAMBDA_NAME" \
                --image-uri "$IMAGE_URI" \
                --region ${{ env.AWS_REGION }} 2>&1 || true)
              echo "Error details: $ERROR_OUTPUT"
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "Update failed, retrying in 15 seconds... (Attempt $RETRY_COUNT/$MAX_RETRIES)"
                sleep 15
              else
                echo "‚ùå Failed to update after $MAX_RETRIES attempts"
                exit 1
              fi
            fi
          done
          
          # Wait for update to complete
          echo "Waiting for update to complete..."
          aws lambda wait function-updated \
            --function-name "$LAMBDA_NAME" \
            --region ${{ env.AWS_REGION }}
          
          echo "‚úÖ Successfully deployed $LAMBDA_NAME to dev"

  approve-staging:
    needs: [determine-environment, detect-changes, build-and-push]
    # Approval required for staging based on branch strategy
    if: success() && needs.detect-changes.outputs.folders != '' && needs.determine-environment.outputs.should-deploy-staging == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: write
      pull-requests: write
    steps:
      - name: Manual Approval for Staging
        uses: trstringer/manual-approval@v1
        with:
          secret: ${{ secrets.GITHUB_TOKEN }}
          approvers: ${{ github.actor }}  # Approver is the person who triggered the workflow
          minimum-approvals: 1
          issue-title: "üöÄ Staging Deployment Approval Required - ${{ github.sha }}"
          issue-body: |
            ## Staging Deployment Approval
            
            **Commit:** ${{ github.sha }}
            **Author:** ${{ github.actor }}
            **Branch:** ${{ github.ref_name }} (${{ needs.determine-environment.outputs.branch-type }})
            **Environment:** ${{ needs.determine-environment.outputs.environment }}
            **Changed Folders:** ${{ needs.detect-changes.outputs.folders }}
            
            Please review and approve this staging deployment.
            
            **To approve:** Comment `/approve` on this issue
            **To reject:** Comment `/reject` on this issue
            
            This deployment will update the following Lambda functions in **staging**:
            - `stg-us-east-lambda-1` (from lambda-function-1)
            - `stg-us-east-lambda-2` (from lambda-function-2)
            - (and other changed functions)
            
            **Note:** Lambda function names follow the pattern: `stg-{region}-lambda-{number}`

  deploy-staging:
    needs: [determine-environment, detect-changes, build-and-push, approve-staging]
    # Deploy to staging based on branch strategy after approval
    if: success() && needs.detect-changes.outputs.folders != '' && needs.determine-environment.outputs.should-deploy-staging == 'true'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        folder: ${{ fromJson(needs.detect-changes.outputs.folders-json) }}
      fail-fast: false
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ env.AWS_ACCOUNT_STAGING }}:role/${{ env.OIDC_ROLE_NAME }}
          role-session-name: GitHubActions-Staging-${{ github.run_id }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Get image URI
        id: image-uri
        run: |
          IMAGE_TAG="${{ matrix.folder }}-${{ github.sha }}"
          IMAGE_URI="${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${IMAGE_TAG}"
          echo "image-uri=${IMAGE_URI}" >> $GITHUB_OUTPUT
          echo "Image URI: ${IMAGE_URI}"

      - name: Deploy Lambda to Staging
        run: |
          # Extract number from folder name (e.g., lambda-function-1 -> 1)
          FOLDER_NAME="${{ matrix.folder }}"
          LAMBDA_NUMBER=$(echo "$FOLDER_NAME" | sed 's/lambda-function-//')
          
          # Convert region from us-east-1 to us-east (remove -1 suffix)
          REGION_SHORT=$(echo "${{ env.AWS_REGION }}" | sed 's/-[0-9]*$//')
          
          # Construct Lambda function name: stg-us-east-lambda-1
          LAMBDA_NAME="stg-${REGION_SHORT}-lambda-${LAMBDA_NUMBER}"
          IMAGE_URI="${{ steps.image-uri.outputs.image-uri }}"
          
          echo "Folder: $FOLDER_NAME"
          echo "Lambda Number: $LAMBDA_NUMBER"
          echo "Region: ${{ env.AWS_REGION }}"
          echo "Deploying $LAMBDA_NAME to staging environment..."
          
          # Wait for any in-progress updates to complete
          echo "Checking for in-progress updates..."
          MAX_WAIT=300  # 5 minutes max wait
          WAIT_TIME=0
          while [ $WAIT_TIME -lt $MAX_WAIT ]; do
            STATE=$(aws lambda get-function --function-name "$LAMBDA_NAME" --region ${{ env.AWS_REGION }} --query 'Configuration.State' --output text 2>/dev/null || echo "Active")
            if [ "$STATE" == "Active" ] || [ "$STATE" == "Inactive" ]; then
              echo "Function is ready for update (State: $STATE)"
              break
            else
              echo "Function state: $STATE, waiting 10 seconds..."
              sleep 10
              WAIT_TIME=$((WAIT_TIME + 10))
            fi
          done
          
          # Update existing Lambda function (functions already exist)
          echo "Updating Lambda function: $LAMBDA_NAME"
          MAX_RETRIES=3
          RETRY_COUNT=0
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            if aws lambda update-function-code \
              --function-name "$LAMBDA_NAME" \
              --image-uri "$IMAGE_URI" \
              --region ${{ env.AWS_REGION }} 2>&1; then
              echo "Update initiated successfully"
              break
            else
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "Update failed, retrying in 15 seconds... (Attempt $RETRY_COUNT/$MAX_RETRIES)"
                sleep 15
              else
                echo "‚ùå Failed to update after $MAX_RETRIES attempts"
                exit 1
              fi
            fi
          done
          
          # Wait for update to complete
          echo "Waiting for update to complete..."
          aws lambda wait function-updated \
            --function-name "$LAMBDA_NAME" \
            --region ${{ env.AWS_REGION }}
          
          echo "‚úÖ Successfully deployed $LAMBDA_NAME to staging"

  approve-production:
    needs: [determine-environment, detect-changes, build-and-push]
    # Approval required for production based on branch strategy
    if: success() && needs.detect-changes.outputs.folders != '' && needs.determine-environment.outputs.should-deploy-prod == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: write
      pull-requests: write
    steps:
      - name: Manual Approval for Production
        uses: trstringer/manual-approval@v1
        with:
          secret: ${{ secrets.GITHUB_TOKEN }}
          approvers: ${{ github.actor }}  # Approver is the person who triggered the workflow
          minimum-approvals: 1
          issue-title: "üöÄ Production Deployment Approval Required - ${{ github.sha }}"
          issue-body: |
            ## Production Deployment Approval
            
            **‚ö†Ô∏è WARNING: This is a PRODUCTION deployment! ‚ö†Ô∏è**
            
            **Commit:** ${{ github.sha }}
            **Author:** ${{ github.actor }}
            **Branch:** ${{ github.ref_name }} (${{ needs.determine-environment.outputs.branch-type }})
            **Environment:** ${{ needs.determine-environment.outputs.environment }}
            **Changed Folders:** ${{ needs.detect-changes.outputs.folders }}
            
            Please carefully review and approve this production deployment.
            
            **To approve:** Comment `/approve` on this issue
            **To reject:** Comment `/reject` on this issue
            
            This deployment will update the following Lambda functions in **PRODUCTION**:
            - `prd-us-east-lambda-1` (from lambda-function-1)
            - `prd-us-east-lambda-2` (from lambda-function-2)
            - (and other changed functions)
            
            **Note:** Lambda function names follow the pattern: `prd-{region}-lambda-{number}`

  deploy-prod:
    needs: [determine-environment, detect-changes, build-and-push, approve-production]
    # Deploy to production based on branch strategy after approval
    if: success() && needs.detect-changes.outputs.folders != '' && needs.determine-environment.outputs.should-deploy-prod == 'true'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        folder: ${{ fromJson(needs.detect-changes.outputs.folders-json) }}
      fail-fast: false
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ env.AWS_ACCOUNT_PROD }}:role/${{ env.OIDC_ROLE_NAME }}
          role-session-name: GitHubActions-Prod-${{ github.run_id }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Get image URI
        id: image-uri
        run: |
          IMAGE_TAG="${{ matrix.folder }}-${{ github.sha }}"
          IMAGE_URI="${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${IMAGE_TAG}"
          echo "image-uri=${IMAGE_URI}" >> $GITHUB_OUTPUT
          echo "Image URI: ${IMAGE_URI}"

      - name: Determine Lambda Function Name
        id: lambda-name
        run: |
          # Extract number from folder name (e.g., lambda-function-1 -> 1)
          FOLDER_NAME="${{ matrix.folder }}"
          LAMBDA_NUMBER=$(echo "$FOLDER_NAME" | sed 's/lambda-function-//')
          
          # Use full region name (e.g., us-east-1)
          REGION_FULL="${{ env.AWS_REGION }}"
          
          # Construct Lambda function name: prd-us-east-1-lambda-1
          LAMBDA_NAME="prd-${REGION_FULL}-lambda-${LAMBDA_NUMBER}"
          
          echo "lambda-name=${LAMBDA_NAME}" >> $GITHUB_OUTPUT
          echo "folder-name=${FOLDER_NAME}" >> $GITHUB_OUTPUT
          echo "lambda-number=${LAMBDA_NUMBER}" >> $GITHUB_OUTPUT
          
          echo "üì¶ Folder: $FOLDER_NAME"
          echo "üî¢ Lambda Number: $LAMBDA_NUMBER"
          echo "üåç Region: ${{ env.AWS_REGION }}"
          echo "üè∑Ô∏è  Actual Lambda Function Name: $LAMBDA_NAME"
          echo "üí≥ AWS Account: ${{ env.AWS_ACCOUNT_PROD }}"

      - name: Deploy ${{ steps.lambda-name.outputs.lambda-name }} to Production
        run: |
          LAMBDA_NAME="${{ steps.lambda-name.outputs.lambda-name }}"
          IMAGE_URI="${{ steps.image-uri.outputs.image-uri }}"
          
          echo "üöÄ Deploying $LAMBDA_NAME to production environment..."
          
          # Wait for any in-progress updates to complete
          echo "Checking for in-progress updates..."
          MAX_WAIT=300  # 5 minutes max wait
          WAIT_TIME=0
          while [ $WAIT_TIME -lt $MAX_WAIT ]; do
            STATE=$(aws lambda get-function --function-name "$LAMBDA_NAME" --region ${{ env.AWS_REGION }} --query 'Configuration.State' --output text 2>/dev/null || echo "Active")
            if [ "$STATE" == "Active" ] || [ "$STATE" == "Inactive" ]; then
              echo "Function is ready for update (State: $STATE)"
              break
            else
              echo "Function state: $STATE, waiting 10 seconds..."
              sleep 10
              WAIT_TIME=$((WAIT_TIME + 10))
            fi
          done
          
          # Update existing Lambda function (functions already exist)
          echo "Updating Lambda function: $LAMBDA_NAME"
          MAX_RETRIES=3
          RETRY_COUNT=0
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            if aws lambda update-function-code \
              --function-name "$LAMBDA_NAME" \
              --image-uri "$IMAGE_URI" \
              --region ${{ env.AWS_REGION }} 2>&1; then
              echo "Update initiated successfully"
              break
            else
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "Update failed, retrying in 15 seconds... (Attempt $RETRY_COUNT/$MAX_RETRIES)"
                sleep 15
              else
                echo "‚ùå Failed to update after $MAX_RETRIES attempts"
                exit 1
              fi
            fi
          done
          
          # Wait for update to complete
          echo "Waiting for update to complete..."
          aws lambda wait function-updated \
            --function-name "$LAMBDA_NAME" \
            --region ${{ env.AWS_REGION }}
          
          echo "‚úÖ Successfully deployed $LAMBDA_NAME to production"

