name: Build, Push and Deploy Lambda Functions

on:
  push:
    branches:
      - main
      - develop
    paths:
      - 'lambda-functions/**'
  pull_request:
    branches:
      - main
      - develop
    paths:
      - 'lambda-functions/**'

env:
  AWS_REGION: us-east-1  # Change to your AWS region
  ECR_REPOSITORY: lambda-function-1-repo  # Single ECR repository for all Lambda functions

jobs:
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      folders: ${{ steps.changes.outputs.folders }}
      folders-json: ${{ steps.changes.outputs.folders-json }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2  # Need depth 2 to compare with previous commit

      - name: Install jq
        run: |
          sudo apt-get update
          sudo apt-get install -y jq

      - name: Detect changed folders
        id: changes
        run: |
          # Get list of changed files
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            # For PRs, compare with base branch
            BASE_SHA="${{ github.event.pull_request.base.sha }}"
            HEAD_SHA="${{ github.sha }}"
          else
            # For pushes, compare with previous commit
            BASE_SHA="${{ github.event.before }}"
            HEAD_SHA="${{ github.sha }}"
          fi

          echo "BASE_SHA: $BASE_SHA"
          echo "HEAD_SHA: $HEAD_SHA"
          echo "Event: ${{ github.event_name }}"

          # Get changed files and extract unique folder names
          if [ -z "$BASE_SHA" ] || [ "$BASE_SHA" == "$HEAD_SHA" ] || [ "$BASE_SHA" == "0000000000000000000000000000000000000000" ]; then
            echo "No previous commit found or initial commit, checking all lambda function folders"
            # Get all folders in lambda-functions directory
            if [ -d "lambda-functions" ]; then
              CHANGED_FOLDERS=$(ls -d lambda-functions/*/ 2>/dev/null | xargs -n1 basename | sort)
            else
              CHANGED_FOLDERS=""
            fi
          else
            # Get changed files and extract unique folder names
            # Try multiple methods to get changed files
            if git rev-parse --verify "$BASE_SHA" >/dev/null 2>&1; then
              CHANGED_FILES=$(git diff --name-only $BASE_SHA $HEAD_SHA 2>/dev/null || echo "")
            else
              # If BASE_SHA doesn't exist, compare with HEAD~1
              CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD 2>/dev/null || echo "")
            fi
            
            echo "Changed files:"
            echo "$CHANGED_FILES"
            
            # Extract unique folder names from lambda-functions directory
            if [ -n "$CHANGED_FILES" ]; then
              CHANGED_FOLDERS=$(echo "$CHANGED_FILES" | grep "^lambda-functions/" | cut -d'/' -f2 | sort -u | tr '\n' ' ' | xargs)
            else
              CHANGED_FOLDERS=""
            fi
          fi

          echo "Detected folders: $CHANGED_FOLDERS"

          # Filter to only include folders that exist and build JSON array
          FOLDER_ARRAY=()
          if [ -n "$CHANGED_FOLDERS" ]; then
            for folder in $CHANGED_FOLDERS; do
              folder=$(echo "$folder" | xargs)  # Trim whitespace
              if [ -n "$folder" ] && [ -d "lambda-functions/$folder" ]; then
                FOLDER_ARRAY+=("$folder")
                echo "Added folder: $folder"
              fi
            done
          fi

          echo "Final folder array size: ${#FOLDER_ARRAY[@]}"

          if [ ${#FOLDER_ARRAY[@]} -eq 0 ]; then
            echo "No lambda function folders changed"
            echo "folders=" >> $GITHUB_OUTPUT
            {
              echo "folders-json<<EOF"
              echo "[]"
              echo "EOF"
            } >> $GITHUB_OUTPUT
          else
            # Create space-separated string for folders output
            EXISTING_FOLDERS=$(IFS=' '; echo "${FOLDER_ARRAY[*]}")
            echo "Changed folders: $EXISTING_FOLDERS"
            echo "folders=$EXISTING_FOLDERS" >> $GITHUB_OUTPUT
            
            # Convert to JSON array properly - ensure compact JSON without extra whitespace
            # Use jq -c to get compact JSON (single line, no extra whitespace)
            JSON_FOLDERS=$(printf '%s\n' "${FOLDER_ARRAY[@]}" | jq -R . | jq -s . | jq -c .)
            # Remove any trailing newlines and ensure it's truly a single line
            JSON_FOLDERS=$(echo -n "$JSON_FOLDERS" | tr -d '\n\r')
            # Validate JSON is valid
            if ! echo "$JSON_FOLDERS" | jq empty > /dev/null 2>&1; then
              echo "ERROR: Generated invalid JSON: $JSON_FOLDERS"
              exit 1
            fi
            # Output JSON directly (compact JSON should work without delimiter syntax)
            echo "folders-json=$JSON_FOLDERS" >> $GITHUB_OUTPUT
            echo "JSON output (compact): $JSON_FOLDERS"
          fi

      - name: Output changed folders
        run: |
          echo "=== Change Detection Results ==="
          echo "Step outputs:"
          echo "  folders: '${{ steps.changes.outputs.folders }}'"
          echo "  folders-json: '${{ steps.changes.outputs.folders-json }}'"
          echo ""
          echo "Job outputs (for next job):"
          echo "  folders: '${{ needs.detect-changes.outputs.folders }}'"
          echo "  folders-json: '${{ needs.detect-changes.outputs.folders-json }}'"
          echo ""
          if [ -z "${{ steps.changes.outputs.folders }}" ]; then
            echo "‚ö†Ô∏è  WARNING: Folders output is empty - build job will be skipped"
          else
            echo "‚úÖ Folders detected: ${{ steps.changes.outputs.folders }}"
            echo "‚úÖ JSON: ${{ steps.changes.outputs.folders-json }}"
            echo "‚úÖ Build job should run"
          fi

  build-and-push:
    needs: detect-changes
    if: needs.detect-changes.outputs.folders != '' && needs.detect-changes.outputs.folders-json != '' && needs.detect-changes.outputs.folders-json != '[]'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        folder: ${{ fromJson(needs.detect-changes.outputs.folders-json) }}
      fail-fast: false  # Continue building other images even if one fails
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          # Using Access Keys (configured in GitHub Secrets)
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
          # Alternative: Use IAM Role (more secure)
          # If you want to use IAM Role instead, comment out above and uncomment below:
          # role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          # aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set ECR repository and image tags
        id: ecr-config
        run: |
          # Use single ECR repository for all Lambda functions
          ECR_REPO="${{ env.ECR_REPOSITORY }}"
          
          # Image will be tagged with Lambda function name
          # Format: <ecr-repo>:<lambda-function-name>-<commit-sha>
          # Example: lambda-functions-repo:lambda-function-1-abc123
          LAMBDA_NAME="${{ matrix.folder }}"
          
          echo "ECR Repository: $ECR_REPO"
          echo "Lambda Function: $LAMBDA_NAME"
          echo "ecr-repo=$ECR_REPO" >> $GITHUB_OUTPUT
          echo "lambda-name=$LAMBDA_NAME" >> $GITHUB_OUTPUT
          
          # Construct full ECR URI
          FULL_ECR_URI="${{ steps.login-ecr.outputs.registry }}/$ECR_REPO"
          echo "ecr-uri=$FULL_ECR_URI" >> $GITHUB_OUTPUT

      - name: Set image tag
        id: image-tag
        run: |
          # Tag image with Lambda function name and commit SHA
          # Format: <lambda-function-name>-<commit-sha>
          # Example: lambda-function-1-abc123def456
          LAMBDA_NAME="${{ steps.ecr-config.outputs.lambda-name }}"
          COMMIT_SHA="${{ github.sha }}"
          
          IMAGE_TAG="${LAMBDA_NAME}-${COMMIT_SHA}"
          
          echo "tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "Image tag: $IMAGE_TAG"

      - name: Build Docker image
        working-directory: lambda-functions/${{ matrix.folder }}
        run: |
          echo "Building Docker image for lambda function: ${{ matrix.folder }}"
          docker build -t ${{ steps.ecr-config.outputs.ecr-uri }}:${{ steps.image-tag.outputs.tag }} .
          
          echo "Image built successfully with tag: ${{ steps.image-tag.outputs.tag }}"

      - name: Push Docker image to ECR
        run: |
          echo "Pushing image to ECR: ${{ steps.ecr-config.outputs.ecr-uri }}"
          
          # Push with single tag (Lambda name + commit SHA)
          docker push ${{ steps.ecr-config.outputs.ecr-uri }}:${{ steps.image-tag.outputs.tag }}
          
          echo "Image pushed successfully"
          echo "Image URI: ${{ steps.ecr-config.outputs.ecr-uri }}:${{ steps.image-tag.outputs.tag }}"

      - name: Output image details
        run: |
          echo "‚úÖ Successfully built and pushed image for: ${{ matrix.folder }}"
          echo "üì¶ ECR Repository: ${{ steps.ecr-config.outputs.ecr-uri }}"
          echo "üè∑Ô∏è  Tag: ${{ steps.image-tag.outputs.tag }}"
          echo "Image URI: ${{ steps.ecr-config.outputs.ecr-uri }}:${{ steps.image-tag.outputs.tag }}"

  deploy-dev:
    needs: [detect-changes, build-and-push]
    # Deploy to dev on develop branch or main branch
    if: success() && needs.detect-changes.outputs.folders != '' && (github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/main')
    runs-on: ubuntu-latest
    strategy:
      matrix:
        folder: ${{ fromJson(needs.detect-changes.outputs.folders-json) }}
      fail-fast: false
    environment:
      name: dev
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Get image URI
        id: image-uri
        run: |
          IMAGE_TAG="${{ matrix.folder }}-${{ github.sha }}"
          IMAGE_URI="${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${IMAGE_TAG}"
          echo "image-uri=${IMAGE_URI}" >> $GITHUB_OUTPUT
          echo "Image URI: ${IMAGE_URI}"

      - name: Deploy Lambda to Dev
        run: |
          LAMBDA_NAME="${{ matrix.folder }}"
          IMAGE_URI="${{ steps.image-uri.outputs.image-uri }}"
          
          echo "Deploying $LAMBDA_NAME to dev environment..."
          
          # Wait for any in-progress updates to complete
          echo "Checking for in-progress updates..."
          MAX_WAIT=300  # 5 minutes max wait
          WAIT_TIME=0
          while [ $WAIT_TIME -lt $MAX_WAIT ]; do
            STATE=$(aws lambda get-function --function-name "$LAMBDA_NAME" --region ${{ env.AWS_REGION }} --query 'Configuration.State' --output text 2>/dev/null || echo "Active")
            if [ "$STATE" == "Active" ] || [ "$STATE" == "Inactive" ]; then
              echo "Function is ready for update (State: $STATE)"
              break
            else
              echo "Function state: $STATE, waiting 10 seconds..."
              sleep 10
              WAIT_TIME=$((WAIT_TIME + 10))
            fi
          done
          
          # Update existing Lambda function (functions already exist)
          echo "Updating Lambda function: $LAMBDA_NAME"
          MAX_RETRIES=3
          RETRY_COUNT=0
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            if aws lambda update-function-code \
              --function-name "$LAMBDA_NAME" \
              --image-uri "$IMAGE_URI" \
              --region ${{ env.AWS_REGION }} 2>&1; then
              echo "Update initiated successfully"
              break
            else
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "Update failed, retrying in 15 seconds... (Attempt $RETRY_COUNT/$MAX_RETRIES)"
                sleep 15
              else
                echo "‚ùå Failed to update after $MAX_RETRIES attempts"
                exit 1
              fi
            fi
          done
          
          # Wait for update to complete
          echo "Waiting for update to complete..."
          aws lambda wait function-updated \
            --function-name "$LAMBDA_NAME" \
            --region ${{ env.AWS_REGION }}
          
          echo "‚úÖ Successfully deployed $LAMBDA_NAME to dev"

  deploy-staging:
    needs: [detect-changes, build-and-push]
    # Deploy to staging only on main branch
    if: success() && needs.detect-changes.outputs.folders != '' && github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        folder: ${{ fromJson(needs.detect-changes.outputs.folders-json) }}
      fail-fast: false
    environment:
      name: staging
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Manual Approval for Staging Deployment
        uses: tricycle/approval-action@v1
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          approval-message: '‚ö†Ô∏è **Staging Deployment Approval Required** ‚ö†Ô∏è

          The following Lambda functions will be deployed to **staging**:
          - ${{ matrix.folder }}

          **Commit**: ${{ github.sha }}
          **Author**: ${{ github.actor }}
          **Message**: ${{ github.event.head_commit.message }}

          Please review and approve to proceed with staging deployment.'

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Get image URI
        id: image-uri
        run: |
          IMAGE_TAG="${{ matrix.folder }}-${{ github.sha }}"
          IMAGE_URI="${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${IMAGE_TAG}"
          echo "image-uri=${IMAGE_URI}" >> $GITHUB_OUTPUT
          echo "Image URI: ${IMAGE_URI}"

      - name: Deploy Lambda to Staging
        run: |
          LAMBDA_NAME="${{ matrix.folder }}"
          IMAGE_URI="${{ steps.image-uri.outputs.image-uri }}"
          
          echo "Deploying $LAMBDA_NAME to staging environment..."
          
          # Wait for any in-progress updates to complete
          echo "Checking for in-progress updates..."
          MAX_WAIT=300  # 5 minutes max wait
          WAIT_TIME=0
          while [ $WAIT_TIME -lt $MAX_WAIT ]; do
            STATE=$(aws lambda get-function --function-name "$LAMBDA_NAME" --region ${{ env.AWS_REGION }} --query 'Configuration.State' --output text 2>/dev/null || echo "Active")
            if [ "$STATE" == "Active" ] || [ "$STATE" == "Inactive" ]; then
              echo "Function is ready for update (State: $STATE)"
              break
            else
              echo "Function state: $STATE, waiting 10 seconds..."
              sleep 10
              WAIT_TIME=$((WAIT_TIME + 10))
            fi
          done
          
          # Update existing Lambda function (functions already exist)
          echo "Updating Lambda function: $LAMBDA_NAME"
          MAX_RETRIES=3
          RETRY_COUNT=0
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            if aws lambda update-function-code \
              --function-name "$LAMBDA_NAME" \
              --image-uri "$IMAGE_URI" \
              --region ${{ env.AWS_REGION }} 2>&1; then
              echo "Update initiated successfully"
              break
            else
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "Update failed, retrying in 15 seconds... (Attempt $RETRY_COUNT/$MAX_RETRIES)"
                sleep 15
              else
                echo "‚ùå Failed to update after $MAX_RETRIES attempts"
                exit 1
              fi
            fi
          done
          
          # Wait for update to complete
          echo "Waiting for update to complete..."
          aws lambda wait function-updated \
            --function-name "$LAMBDA_NAME" \
            --region ${{ env.AWS_REGION }}
          
          echo "‚úÖ Successfully deployed $LAMBDA_NAME to staging"

  deploy-prod:
    needs: [detect-changes, build-and-push]
    # Deploy to production only on main branch
    if: success() && needs.detect-changes.outputs.folders != '' && github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        folder: ${{ fromJson(needs.detect-changes.outputs.folders-json) }}
      fail-fast: false
    environment:
      name: production
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Manual Approval for Production Deployment
        uses: tricycle/approval-action@v1
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          approval-message: 'üö® **PRODUCTION Deployment Approval Required** üö®

          The following Lambda functions will be deployed to **PRODUCTION**:
          - ${{ matrix.folder }}

          **Commit**: ${{ github.sha }}
          **Author**: ${{ github.actor }}
          **Message**: ${{ github.event.head_commit.message }}

          ‚ö†Ô∏è **WARNING**: This will update production Lambda functions. Please review carefully before approving.'

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Get image URI
        id: image-uri
        run: |
          IMAGE_TAG="${{ matrix.folder }}-${{ github.sha }}"
          IMAGE_URI="${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${IMAGE_TAG}"
          echo "image-uri=${IMAGE_URI}" >> $GITHUB_OUTPUT
          echo "Image URI: ${IMAGE_URI}"

      - name: Deploy Lambda to Production
        run: |
          LAMBDA_NAME="${{ matrix.folder }}"
          IMAGE_URI="${{ steps.image-uri.outputs.image-uri }}"
          
          echo "Deploying $LAMBDA_NAME to production environment..."
          
          # Wait for any in-progress updates to complete
          echo "Checking for in-progress updates..."
          MAX_WAIT=300  # 5 minutes max wait
          WAIT_TIME=0
          while [ $WAIT_TIME -lt $MAX_WAIT ]; do
            STATE=$(aws lambda get-function --function-name "$LAMBDA_NAME" --region ${{ env.AWS_REGION }} --query 'Configuration.State' --output text 2>/dev/null || echo "Active")
            if [ "$STATE" == "Active" ] || [ "$STATE" == "Inactive" ]; then
              echo "Function is ready for update (State: $STATE)"
              break
            else
              echo "Function state: $STATE, waiting 10 seconds..."
              sleep 10
              WAIT_TIME=$((WAIT_TIME + 10))
            fi
          done
          
          # Update existing Lambda function (functions already exist)
          echo "Updating Lambda function: $LAMBDA_NAME"
          MAX_RETRIES=3
          RETRY_COUNT=0
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            if aws lambda update-function-code \
              --function-name "$LAMBDA_NAME" \
              --image-uri "$IMAGE_URI" \
              --region ${{ env.AWS_REGION }} 2>&1; then
              echo "Update initiated successfully"
              break
            else
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "Update failed, retrying in 15 seconds... (Attempt $RETRY_COUNT/$MAX_RETRIES)"
                sleep 15
              else
                echo "‚ùå Failed to update after $MAX_RETRIES attempts"
                exit 1
              fi
            fi
          done
          
          # Wait for update to complete
          echo "Waiting for update to complete..."
          aws lambda wait function-updated \
            --function-name "$LAMBDA_NAME" \
            --region ${{ env.AWS_REGION }}
          
          echo "‚úÖ Successfully deployed $LAMBDA_NAME to production"

