name: Build and Push Lambda Images to ECR

on:
  push:
    branches:
      - main
      - develop
    paths:
      - 'lambda-functions/**'
  pull_request:
    branches:
      - main
      - develop
    paths:
      - 'lambda-functions/**'

env:
  AWS_REGION: us-east-1  # Change to your AWS region

jobs:
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      changed-folders: ${{ steps.changes.outputs.folders }}
      folders-json: ${{ steps.changes.outputs.folders-json }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2  # Need depth 2 to compare with previous commit

      - name: Install jq
        run: |
          sudo apt-get update
          sudo apt-get install -y jq

      - name: Detect changed folders
        id: changes
        run: |
          # Get list of changed files
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            # For PRs, compare with base branch
            BASE_SHA="${{ github.event.pull_request.base.sha }}"
            HEAD_SHA="${{ github.sha }}"
          else
            # For pushes, compare with previous commit
            BASE_SHA="${{ github.event.before }}"
            HEAD_SHA="${{ github.sha }}"
          fi

          echo "BASE_SHA: $BASE_SHA"
          echo "HEAD_SHA: $HEAD_SHA"
          echo "Event: ${{ github.event_name }}"

          # Get changed files and extract unique folder names
          if [ -z "$BASE_SHA" ] || [ "$BASE_SHA" == "$HEAD_SHA" ] || [ "$BASE_SHA" == "0000000000000000000000000000000000000000" ]; then
            echo "No previous commit found or initial commit, checking all lambda function folders"
            # Get all folders in lambda-functions directory
            if [ -d "lambda-functions" ]; then
              CHANGED_FOLDERS=$(ls -d lambda-functions/*/ 2>/dev/null | xargs -n1 basename | sort)
            else
              CHANGED_FOLDERS=""
            fi
          else
            # Get changed files and extract unique folder names
            # Try multiple methods to get changed files
            if git rev-parse --verify "$BASE_SHA" >/dev/null 2>&1; then
              CHANGED_FILES=$(git diff --name-only $BASE_SHA $HEAD_SHA 2>/dev/null || echo "")
            else
              # If BASE_SHA doesn't exist, compare with HEAD~1
              CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD 2>/dev/null || echo "")
            fi
            
            echo "Changed files:"
            echo "$CHANGED_FILES"
            
            # Extract unique folder names from lambda-functions directory
            if [ -n "$CHANGED_FILES" ]; then
              CHANGED_FOLDERS=$(echo "$CHANGED_FILES" | grep "^lambda-functions/" | cut -d'/' -f2 | sort -u | tr '\n' ' ' | xargs)
            else
              CHANGED_FOLDERS=""
            fi
          fi

          echo "Detected folders: $CHANGED_FOLDERS"

          # Filter to only include folders that exist and build JSON array
          FOLDER_ARRAY=()
          if [ -n "$CHANGED_FOLDERS" ]; then
            for folder in $CHANGED_FOLDERS; do
              folder=$(echo "$folder" | xargs)  # Trim whitespace
              if [ -n "$folder" ] && [ -d "lambda-functions/$folder" ]; then
                FOLDER_ARRAY+=("$folder")
                echo "Added folder: $folder"
              fi
            done
          fi

          echo "Final folder array size: ${#FOLDER_ARRAY[@]}"

          if [ ${#FOLDER_ARRAY[@]} -eq 0 ]; then
            echo "No lambda function folders changed"
            echo "folders=" >> $GITHUB_OUTPUT
            {
              echo "folders-json<<EOF"
              echo "[]"
              echo "EOF"
            } >> $GITHUB_OUTPUT
          else
            # Create space-separated string for folders output
            EXISTING_FOLDERS=$(IFS=' '; echo "${FOLDER_ARRAY[*]}")
            echo "Changed folders: $EXISTING_FOLDERS"
            echo "folders=$EXISTING_FOLDERS" >> $GITHUB_OUTPUT
            
            # Convert to JSON array properly - ensure compact JSON without extra whitespace
            # Use jq -c to get compact JSON (single line, no extra whitespace)
            JSON_FOLDERS=$(printf '%s\n' "${FOLDER_ARRAY[@]}" | jq -R . | jq -s . | jq -c .)
            # Remove any trailing newlines (jq -c should already produce single line, but be safe)
            JSON_FOLDERS=$(echo "$JSON_FOLDERS" | tr -d '\n' | sed 's/[[:space:]]*$//')
            # Validate JSON is valid
            if ! echo "$JSON_FOLDERS" | jq empty > /dev/null 2>&1; then
              echo "ERROR: Generated invalid JSON: $JSON_FOLDERS"
              exit 1
            fi
            # Use delimiter syntax to properly handle JSON output
            {
              echo "folders-json<<JSONEOF"
              echo "$JSON_FOLDERS"
              echo "JSONEOF"
            } >> $GITHUB_OUTPUT
            echo "JSON output (compact): $JSON_FOLDERS"
          fi

      - name: Output changed folders
        run: |
          echo "=== Change Detection Results ==="
          echo "Folders output: '${{ steps.changes.outputs.folders }}'"
          echo "Folders JSON output: '${{ steps.changes.outputs.folders-json }}'"
          echo "Folders output length: ${#{{ steps.changes.outputs.folders }}}"
          if [ -z "${{ steps.changes.outputs.folders }}" ]; then
            echo "‚ö†Ô∏è  WARNING: Folders output is empty - build job will be skipped"
          else
            echo "‚úÖ Folders detected - build job will run"
          fi

  build-and-push:
    needs: detect-changes
    if: needs.detect-changes.outputs.folders != '' && needs.detect-changes.outputs.folders-json != '[]'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        folder: ${{ fromJson(needs.detect-changes.outputs.folders-json) }}
      fail-fast: false  # Continue building other images even if one fails
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}  # IAM Role ARN
          aws-region: ${{ env.AWS_REGION }}
        # Alternative: Use access keys (less secure)
        # with:
        #   aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        #   aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        #   aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Read ECR repository mapping
        id: ecr-config
        run: |
          # Read the ECR mapping from config file
          ECR_REPO=$(grep "^${{ matrix.folder }}:" .github/lambda-ecr-mapping.txt | cut -d':' -f2 | xargs)
          
          if [ -z "$ECR_REPO" ]; then
            echo "ERROR: No ECR repository mapping found for folder: ${{ matrix.folder }}"
            exit 1
          fi
          
          echo "ECR Repository: $ECR_REPO"
          echo "ecr-repo=$ECR_REPO" >> $GITHUB_OUTPUT
          
          # Extract account ID and region from ECR repo if needed
          # Format: <account-id>.dkr.ecr.<region>.amazonaws.com/<repo-name>
          # Or just: <repo-name> (we'll construct full URI)
          FULL_ECR_URI="${{ steps.login-ecr.outputs.registry }}/$ECR_REPO"
          echo "ecr-uri=$FULL_ECR_URI" >> $GITHUB_OUTPUT

      - name: Set image tag
        id: image-tag
        run: |
          # Use commit SHA as tag for traceability
          IMAGE_TAG="${{ github.sha }}"
          # Also create a 'latest' tag
          echo "tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "tag-latest=latest" >> $GITHUB_OUTPUT
          echo "Image will be tagged as: $IMAGE_TAG and latest"

      - name: Build Docker image
        working-directory: lambda-functions/${{ matrix.folder }}
        run: |
          echo "Building Docker image for lambda function: ${{ matrix.folder }}"
          docker build -t ${{ steps.ecr-config.outputs.ecr-uri }}:${{ steps.image-tag.outputs.tag }} \
                       -t ${{ steps.ecr-config.outputs.ecr-uri }}:${{ steps.image-tag.outputs.tag-latest }} \
                       .
          
          echo "Image built successfully"

      - name: Push Docker image to ECR
        run: |
          echo "Pushing image to ECR: ${{ steps.ecr-config.outputs.ecr-uri }}"
          
          # Push with commit SHA tag
          docker push ${{ steps.ecr-config.outputs.ecr-uri }}:${{ steps.image-tag.outputs.tag }}
          
          # Push with latest tag
          docker push ${{ steps.ecr-config.outputs.ecr-uri }}:${{ steps.image-tag.outputs.tag-latest }}
          
          echo "Image pushed successfully"
          echo "Image URI: ${{ steps.ecr-config.outputs.ecr-uri }}:${{ steps.image-tag.outputs.tag }}"

      - name: Output image details
        run: |
          echo "‚úÖ Successfully built and pushed image for: ${{ matrix.folder }}"
          echo "üì¶ ECR Repository: ${{ steps.ecr-config.outputs.ecr-uri }}"
          echo "üè∑Ô∏è  Tags: ${{ steps.image-tag.outputs.tag }}, latest"

