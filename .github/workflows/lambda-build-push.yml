name: Build, Push and Deploy Lambda Functions

on:
  push:
    branches:
      - develop
      - release
    paths:
      - 'lambda-functions/**'
  pull_request:
    branches:
      - develop
      - release
    paths:
      - 'lambda-functions/**'

env:
  MAP_FILE: .github/lambda-repo-map.json
  APPROVAL_EMAILS_STAGING: ${{ secrets.APPROVAL_EMAILS_STAGING || '' }}
  APPROVAL_EMAILS_PRODUCTION: ${{ secrets.APPROVAL_EMAILS_PRODUCTION || '' }}

jobs:
  determine-environment:
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.env.outputs.environment }}
      should-deploy-dev: ${{ steps.env.outputs.should-deploy-dev }}
      should-deploy-staging: ${{ steps.env.outputs.should-deploy-staging }}
      should-deploy-prod: ${{ steps.env.outputs.should-deploy-prod }}
      branch-type: ${{ steps.env.outputs.branch-type }}
      aws-region: ${{ steps.env.outputs.aws-region }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Determine environment from branch mapping
        id: env
        run: |
          BRANCH_NAME="${{ github.ref_name }}"
          BRANCH_REF="${{ github.ref }}"
          IS_PR="${{ github.event_name == 'pull_request' }}"
          MAP_FILE="${{ env.MAP_FILE }}"
          
          # Load base config
          AWS_REGION=$(jq -r '.aws_base_config.region' "$MAP_FILE")
          echo "aws-region=$AWS_REGION" >> $GITHUB_OUTPUT
          
          echo "Branch: $BRANCH_NAME"
          echo "Ref: $BRANCH_REF"
          echo "Is PR: $IS_PR"
          echo "AWS Region: $AWS_REGION"
          
          # Initialize defaults
          ENVIRONMENT="none"
          DEPLOY_DEV="false"
          DEPLOY_STAGING="false"
          DEPLOY_PROD="false"
          BRANCH_TYPE="unknown"
          
          # Pull requests: Build only, no deployment
          if [ "$IS_PR" == "true" ]; then
            ENVIRONMENT="pr"
            BRANCH_TYPE="pull_request"
            echo "üîç Pull Request detected - Build only, no deployment"
          
          # Check branch mapping from config file
          elif [ -f "$MAP_FILE" ]; then
            BRANCH_CONFIG=$(jq -r ".branch_mapping.\"$BRANCH_NAME\" // empty" "$MAP_FILE")
            
            if [ -n "$BRANCH_CONFIG" ] && [ "$BRANCH_CONFIG" != "null" ]; then
              ENVIRONMENTS=$(echo "$BRANCH_CONFIG" | jq -r '.environments[] // empty')
              AUTO_DEPLOY=$(echo "$BRANCH_CONFIG" | jq -r '.auto_deploy // false')
              
              if [ -n "$ENVIRONMENTS" ]; then
                for env in $ENVIRONMENTS; do
                  case "$env" in
                    "dev")
                      DEPLOY_DEV="true"
                      if [ "$ENVIRONMENT" == "none" ]; then
                        ENVIRONMENT="dev"
                      fi
                      ;;
                    "staging")
                      DEPLOY_STAGING="true"
                      if [ "$ENVIRONMENT" == "none" ] || [ "$ENVIRONMENT" == "dev" ]; then
                        ENVIRONMENT="release"
                      fi
                      ;;
                    "prod")
                      DEPLOY_PROD="true"
                      if [ "$ENVIRONMENT" == "none" ] || [ "$ENVIRONMENT" == "dev" ]; then
                        ENVIRONMENT="release"
                      fi
                      ;;
                  esac
                done
                BRANCH_TYPE="$BRANCH_NAME"
                echo "‚úÖ Branch mapping found: $BRANCH_NAME ‚Üí $ENVIRONMENTS"
              fi
            fi
          fi
          
          # Fallback to hardcoded logic if mapping not found
          if [ "$ENVIRONMENT" == "none" ]; then
            if [ "$BRANCH_REF" == "refs/heads/develop" ]; then
              ENVIRONMENT="dev"
              DEPLOY_DEV="true"
              BRANCH_TYPE="develop"
              echo "üíª Develop branch detected - Dev deployment (automatic)"
            elif [ "$BRANCH_REF" == "refs/heads/release" ]; then
              ENVIRONMENT="release"
              DEPLOY_STAGING="true"
              DEPLOY_PROD="true"
              BRANCH_TYPE="release"
              echo "üöÄ Release branch detected - Staging and Production deployment (with approval)"
            else
              ENVIRONMENT="unknown"
              BRANCH_TYPE="other"
              echo "‚ùì Unknown branch type - Build only, no deployment"
            fi
          fi
          
          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
          echo "should-deploy-dev=$DEPLOY_DEV" >> $GITHUB_OUTPUT
          echo "should-deploy-staging=$DEPLOY_STAGING" >> $GITHUB_OUTPUT
          echo "should-deploy-prod=$DEPLOY_PROD" >> $GITHUB_OUTPUT
          echo "branch-type=$BRANCH_TYPE" >> $GITHUB_OUTPUT
          
          echo "üìä Deployment Summary:"
          echo "  Environment: $ENVIRONMENT"
          echo "  Deploy to Dev: $DEPLOY_DEV"
          echo "  Deploy to Staging: $DEPLOY_STAGING"
          echo "  Deploy to Production: $DEPLOY_PROD"
          echo "  Branch Type: $BRANCH_TYPE"

  detect-changes:
    needs: determine-environment
    runs-on: ubuntu-latest
    outputs:
      folders: ${{ steps.changes.outputs.folders }}
      folders-json: ${{ steps.changes.outputs.folders-json }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2  # Need depth 2 to compare with previous commit

      - name: Install jq
        run: |
          sudo apt-get update
          sudo apt-get install -y jq

      - name: Detect changed folders
        id: changes
        run: |
          # Get list of changed files
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            # For PRs, compare with base branch
            BASE_SHA="${{ github.event.pull_request.base.sha }}"
            HEAD_SHA="${{ github.sha }}"
          else
            # For pushes, compare with previous commit
            BASE_SHA="${{ github.event.before }}"
            HEAD_SHA="${{ github.sha }}"
          fi

          echo "BASE_SHA: $BASE_SHA"
          echo "HEAD_SHA: $HEAD_SHA"
          echo "Event: ${{ github.event_name }}"

          # Get changed files and extract unique folder names
          if [ -z "$BASE_SHA" ] || [ "$BASE_SHA" == "$HEAD_SHA" ] || [ "$BASE_SHA" == "0000000000000000000000000000000000000000" ]; then
            echo "No previous commit found or initial commit, checking all lambda function folders"
            # Get all folders in lambda-functions directory
            if [ -d "lambda-functions" ]; then
              CHANGED_FOLDERS=$(ls -d lambda-functions/*/ 2>/dev/null | xargs -n1 basename | sort)
            else
              CHANGED_FOLDERS=""
            fi
          else
            # Get changed files and extract unique folder names
            # Try multiple methods to get changed files
            if git rev-parse --verify "$BASE_SHA" >/dev/null 2>&1; then
              CHANGED_FILES=$(git diff --name-only $BASE_SHA $HEAD_SHA 2>/dev/null || echo "")
            else
              # If BASE_SHA doesn't exist, compare with HEAD~1
              CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD 2>/dev/null || echo "")
            fi
            
            echo "Changed files:"
            echo "$CHANGED_FILES"
            
            # Extract unique folder names from lambda-functions directory
            if [ -n "$CHANGED_FILES" ]; then
              CHANGED_FOLDERS=$(echo "$CHANGED_FILES" | grep "^lambda-functions/" | cut -d'/' -f2 | sort -u | tr '\n' ' ' | xargs)
            else
              CHANGED_FOLDERS=""
            fi
          fi

          echo "Detected folders: $CHANGED_FOLDERS"

          # Filter to only include folders that exist and build JSON array
          FOLDER_ARRAY=()
          if [ -n "$CHANGED_FOLDERS" ]; then
            for folder in $CHANGED_FOLDERS; do
              folder=$(echo "$folder" | xargs)  # Trim whitespace
              if [ -n "$folder" ] && [ -d "lambda-functions/$folder" ]; then
                FOLDER_ARRAY+=("$folder")
                echo "Added folder: $folder"
              fi
            done
          fi

          echo "Final folder array size: ${#FOLDER_ARRAY[@]}"

          if [ ${#FOLDER_ARRAY[@]} -eq 0 ]; then
            echo "No lambda function folders changed"
            echo "folders=" >> $GITHUB_OUTPUT
            {
              echo "folders-json<<EOF"
              echo "[]"
              echo "EOF"
            } >> $GITHUB_OUTPUT
          else
            # Create space-separated string for folders output
            EXISTING_FOLDERS=$(IFS=' '; echo "${FOLDER_ARRAY[*]}")
            echo "Changed folders: $EXISTING_FOLDERS"
            echo "folders=$EXISTING_FOLDERS" >> $GITHUB_OUTPUT
            
            # Convert to JSON array properly - ensure compact JSON without extra whitespace
            # Use jq -c to get compact JSON (single line, no extra whitespace)
            JSON_FOLDERS=$(printf '%s\n' "${FOLDER_ARRAY[@]}" | jq -R . | jq -s . | jq -c .)
            # Remove any trailing newlines and ensure it's truly a single line
            JSON_FOLDERS=$(echo -n "$JSON_FOLDERS" | tr -d '\n\r')
            # Validate JSON is valid
            if ! echo "$JSON_FOLDERS" | jq empty > /dev/null 2>&1; then
              echo "ERROR: Generated invalid JSON: $JSON_FOLDERS"
              exit 1
            fi
            # Output JSON directly (compact JSON should work without delimiter syntax)
            echo "folders-json=$JSON_FOLDERS" >> $GITHUB_OUTPUT
            echo "JSON output (compact): $JSON_FOLDERS"
          fi

      - name: Output changed folders
        run: |
          echo "=== Change Detection Results ==="
          echo "Step outputs:"
          echo "  folders: '${{ steps.changes.outputs.folders }}'"
          echo "  folders-json: '${{ steps.changes.outputs.folders-json }}'"
          echo ""
          echo "Job outputs (for next job):"
          echo "  folders: '${{ needs.detect-changes.outputs.folders }}'"
          echo "  folders-json: '${{ needs.detect-changes.outputs.folders-json }}'"
          echo ""
          if [ -z "${{ steps.changes.outputs.folders }}" ]; then
            echo "‚ö†Ô∏è  WARNING: Folders output is empty - build job will be skipped"
          else
            echo "‚úÖ Folders detected: ${{ steps.changes.outputs.folders }}"
            echo "‚úÖ JSON: ${{ steps.changes.outputs.folders-json }}"
            echo "‚úÖ Build job should run"
          fi

  build-and-push:
    needs: [determine-environment, detect-changes]
    # Build on all branches (including PRs and feature branches)
    if: needs.detect-changes.outputs.folders != '' && needs.detect-changes.outputs.folders-json != '' && needs.detect-changes.outputs.folders-json != '[]'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        folder: ${{ fromJson(needs.detect-changes.outputs.folders-json) }}
      fail-fast: false  # Continue building other images even if one fails
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Load Lambda Configuration from Mapping
        id: lambda-config
        run: |
          MAP_FILE="${{ env.MAP_FILE }}"
          FOLDER_NAME="${{ matrix.folder }}"
          ENVIRONMENT="${{ needs.determine-environment.outputs.environment }}"
          AWS_REGION="${{ needs.determine-environment.outputs.aws-region }}"
          COMMIT_SHA="${{ github.sha }}"
          
          # Determine target environment for build (dev for PRs/builds, staging for release)
          if [ "$ENVIRONMENT" == "pr" ] || [ "$ENVIRONMENT" == "dev" ] || [ "$ENVIRONMENT" == "unknown" ]; then
            BUILD_ENV="dev"
          elif [ "$ENVIRONMENT" == "release" ]; then
            BUILD_ENV="staging"
          else
            BUILD_ENV="dev"
          fi
          
          # Load function config from mapping
          FUNCTION=$(jq -r ".lambda_functions[] | select(.folder_name == \"$FOLDER_NAME\")" "$MAP_FILE")
          
          if [ -z "$FUNCTION" ] || [ "$FUNCTION" == "null" ]; then
            echo "‚ùå ERROR: Function $FOLDER_NAME not found in mapping file"
            exit 1
          fi
          
          FUNCTION_NUMBER=$(echo "$FUNCTION" | jq -r '.function_number')
          ECR_REF=$(echo "$FUNCTION" | jq -r ".ecr_repository_ref.$BUILD_ENV")
          
          # Load environment config
          ENV_CONFIG=$(jq -r ".aws_base_config.environments.$BUILD_ENV" "$MAP_FILE")
          ACCOUNT_ID=$(echo "$ENV_CONFIG" | jq -r '.account_id')
          ENV_PREFIX=$(echo "$ENV_CONFIG" | jq -r '.env_prefix')
          
          # Get ECR repository name
          ECR_REPO_NAME=$(jq -r ".ecr_config.repositories.$ECR_REF.name" "$MAP_FILE")
          
          # Construct OIDC ARN
          OIDC_ROLE_NAME=$(jq -r '.oidc_config.role_name' "$MAP_FILE")
          OIDC_ARN="arn:aws:iam::${ACCOUNT_ID}:role/${OIDC_ROLE_NAME}"
          
          # Construct Lambda name
          LAMBDA_NAME="${ENV_PREFIX}-${AWS_REGION}-lambda-${FUNCTION_NUMBER}"
          
          # Construct ECR URI
          ECR_URI="${ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPO_NAME}"
          
          # Construct image tag
          IMAGE_TAG="${LAMBDA_NAME}-${COMMIT_SHA}"
          
          # For release branch, also get production ECR info
          ECR_URI_PROD=""
          if [ "$ENVIRONMENT" == "release" ]; then
            ECR_REF_PROD=$(echo "$FUNCTION" | jq -r ".ecr_repository_ref.prod")
            ECR_REPO_NAME_PROD=$(jq -r ".ecr_config.repositories.$ECR_REF_PROD.name" "$MAP_FILE")
            ECR_URI_PROD="${ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPO_NAME_PROD}"
            echo "ecr-repo-name-prod=$ECR_REPO_NAME_PROD" >> $GITHUB_OUTPUT
            echo "ecr-uri-prod=$ECR_URI_PROD" >> $GITHUB_OUTPUT
            echo "Production ECR Repository: $ECR_REPO_NAME_PROD"
            echo "Production ECR URI: $ECR_URI_PROD"
          fi
          
          echo "build-env=$BUILD_ENV" >> $GITHUB_OUTPUT
          echo "account-id=$ACCOUNT_ID" >> $GITHUB_OUTPUT
          echo "env-prefix=$ENV_PREFIX" >> $GITHUB_OUTPUT
          echo "oidc-arn=$OIDC_ARN" >> $GITHUB_OUTPUT
          echo "ecr-repo-name=$ECR_REPO_NAME" >> $GITHUB_OUTPUT
          echo "ecr-uri=$ECR_URI" >> $GITHUB_OUTPUT
          echo "lambda-name=$LAMBDA_NAME" >> $GITHUB_OUTPUT
          echo "image-tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "folder-name=$FOLDER_NAME" >> $GITHUB_OUTPUT
          
          echo "‚úÖ Configuration loaded:"
          echo "  Environment: $BUILD_ENV"
          echo "  Account ID: $ACCOUNT_ID"
          echo "  Lambda Name: $LAMBDA_NAME"
          echo "  ECR Repository: $ECR_REPO_NAME"
          echo "  ECR URI: $ECR_URI"
          echo "  Image Tag: $IMAGE_TAG"

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ steps.lambda-config.outputs.oidc-arn }}
          role-session-name: GitHubActions-Build-${{ github.run_id }}
          aws-region: ${{ needs.determine-environment.outputs.aws-region }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push AMD64 image
        working-directory: lambda-functions/${{ matrix.folder }}
        run: |
          ECR_URI="${{ steps.lambda-config.outputs.ecr-uri }}"
          IMAGE_TAG="${{ steps.lambda-config.outputs.image-tag }}"
          FULL_IMAGE_URI_AMD64="${ECR_URI}:${IMAGE_TAG}-amd64"
          
          # Extract repository name and region from ECR URI
          ECR_REPO_NAME=$(echo "$ECR_URI" | sed 's|.*/||')
          AWS_REGION="${{ needs.determine-environment.outputs.aws-region }}"
          IMAGE_TAG_ONLY="${IMAGE_TAG}-amd64"
          
          echo "Building AMD64 Docker image for lambda function: ${{ matrix.folder }}"
          echo "Image URI: $FULL_IMAGE_URI_AMD64"
          
          # Check if image already exists in ECR
          echo "Checking if image tag already exists..."
          if aws ecr describe-images \
            --repository-name "$ECR_REPO_NAME" \
            --image-ids imageTag="$IMAGE_TAG_ONLY" \
            --region "$AWS_REGION" \
            >/dev/null 2>&1; then
            echo "‚ö†Ô∏è  Image tag $IMAGE_TAG_ONLY already exists in $ECR_REPO_NAME. Skipping build and push."
            echo "‚ÑπÔ∏è  Using existing image: $FULL_IMAGE_URI_AMD64"
          else
            echo "Image tag does not exist. Building and pushing..."
            docker buildx build \
              --platform linux/amd64 \
              --tag "$FULL_IMAGE_URI_AMD64" \
              --push \
              --provenance=false \
              --sbom=false \
              .
            echo "‚úÖ AMD64 image built and pushed to staging ECR"
          fi
          
          # If production ECR is configured (release branch), also push to production repo
          if [ -n "${{ steps.lambda-config.outputs.ecr-uri-prod }}" ]; then
            PROD_IMAGE_URI_AMD64="${{ steps.lambda-config.outputs.ecr-uri-prod }}:${IMAGE_TAG}-amd64"
            PROD_ECR_REPO_NAME=$(echo "${{ steps.lambda-config.outputs.ecr-uri-prod }}" | sed 's|.*/||')
            echo "Checking if production image tag already exists..."
            if aws ecr describe-images \
              --repository-name "$PROD_ECR_REPO_NAME" \
              --image-ids imageTag="${IMAGE_TAG}-amd64" \
              --region "$AWS_REGION" \
              >/dev/null 2>&1; then
              echo "‚ö†Ô∏è  Production image tag ${IMAGE_TAG}-amd64 already exists in $PROD_ECR_REPO_NAME. Skipping push."
            else
              echo "Pushing AMD64 image to production ECR: $PROD_IMAGE_URI_AMD64"
              docker pull "$FULL_IMAGE_URI_AMD64"
              docker tag "$FULL_IMAGE_URI_AMD64" "$PROD_IMAGE_URI_AMD64"
              docker push "$PROD_IMAGE_URI_AMD64"
              echo "‚úÖ AMD64 image also pushed to production ECR"
            fi
          fi

      - name: Build and push ARM64 image
        working-directory: lambda-functions/${{ matrix.folder }}
        run: |
          ECR_URI="${{ steps.lambda-config.outputs.ecr-uri }}"
          IMAGE_TAG="${{ steps.lambda-config.outputs.image-tag }}"
          FULL_IMAGE_URI_ARM64="${ECR_URI}:${IMAGE_TAG}-arm64"
          
          # Extract repository name and region from ECR URI
          ECR_REPO_NAME=$(echo "$ECR_URI" | sed 's|.*/||')
          AWS_REGION="${{ needs.determine-environment.outputs.aws-region }}"
          IMAGE_TAG_ONLY="${IMAGE_TAG}-arm64"
          
          echo "Building ARM64 Docker image for lambda function: ${{ matrix.folder }}"
          echo "Image URI: $FULL_IMAGE_URI_ARM64"
          
          # Check if image already exists in ECR
          echo "Checking if image tag already exists..."
          if aws ecr describe-images \
            --repository-name "$ECR_REPO_NAME" \
            --image-ids imageTag="$IMAGE_TAG_ONLY" \
            --region "$AWS_REGION" \
            >/dev/null 2>&1; then
            echo "‚ö†Ô∏è  Image tag $IMAGE_TAG_ONLY already exists in $ECR_REPO_NAME. Skipping build and push."
            echo "‚ÑπÔ∏è  Using existing image: $FULL_IMAGE_URI_ARM64"
          else
            echo "Image tag does not exist. Building and pushing..."
            docker buildx build \
              --platform linux/arm64 \
              --tag "$FULL_IMAGE_URI_ARM64" \
              --push \
              --provenance=false \
              --sbom=false \
              .
            echo "‚úÖ ARM64 image built and pushed to staging ECR"
          fi
          
          # If production ECR is configured (release branch), also push to production repo
          if [ -n "${{ steps.lambda-config.outputs.ecr-uri-prod }}" ]; then
            PROD_IMAGE_URI_ARM64="${{ steps.lambda-config.outputs.ecr-uri-prod }}:${IMAGE_TAG}-arm64"
            PROD_ECR_REPO_NAME=$(echo "${{ steps.lambda-config.outputs.ecr-uri-prod }}" | sed 's|.*/||')
            echo "Checking if production image tag already exists..."
            if aws ecr describe-images \
              --repository-name "$PROD_ECR_REPO_NAME" \
              --image-ids imageTag="${IMAGE_TAG}-arm64" \
              --region "$AWS_REGION" \
              >/dev/null 2>&1; then
              echo "‚ö†Ô∏è  Production image tag ${IMAGE_TAG}-arm64 already exists in $PROD_ECR_REPO_NAME. Skipping push."
            else
              echo "Pushing ARM64 image to production ECR: $PROD_IMAGE_URI_ARM64"
              docker pull "$FULL_IMAGE_URI_ARM64"
              docker tag "$FULL_IMAGE_URI_ARM64" "$PROD_IMAGE_URI_ARM64"
              docker push "$PROD_IMAGE_URI_ARM64"
              echo "‚úÖ ARM64 image also pushed to production ECR"
            fi
          fi

      - name: Create multi-architecture manifest list
        run: |
          ECR_URI="${{ steps.lambda-config.outputs.ecr-uri }}"
          IMAGE_TAG="${{ steps.lambda-config.outputs.image-tag }}"
          FULL_IMAGE_URI="${ECR_URI}:${IMAGE_TAG}"
          
          echo "Creating multi-architecture manifest list from architecture-specific images..."
          # Create a manifest list that combines both architectures
          # This allows Docker to automatically select the correct architecture when pulling
          # Handle case where manifest already exists (immutable tags)
          set +e
          OUTPUT=$(docker buildx imagetools create \
            --tag "$FULL_IMAGE_URI" \
            "${ECR_URI}:${IMAGE_TAG}-amd64" \
            "${ECR_URI}:${IMAGE_TAG}-arm64" 2>&1)
          EXIT_CODE=$?
          set -e
          
          if [ $EXIT_CODE -eq 0 ]; then
            echo "‚úÖ Multi-architecture manifest list created successfully"
          elif echo "$OUTPUT" | grep -q "already exists\|immutable\|cannot be overwritten"; then
            echo "‚ö†Ô∏è  Manifest list already exists for $FULL_IMAGE_URI. Using existing manifest."
          else
            echo "‚ö†Ô∏è  Warning: Failed to create manifest list: $OUTPUT"
            echo "Continuing with deployment..."
          fi
          
          echo "üì¶ Multi-arch manifest: $FULL_IMAGE_URI"
          echo "üì¶ AMD64 single-arch: ${ECR_URI}:${IMAGE_TAG}-amd64"
          echo "üì¶ ARM64 single-arch: ${ECR_URI}:${IMAGE_TAG}-arm64"
          
          # If production ECR is configured (release branch), also create manifest list for production
          if [ -n "${{ steps.lambda-config.outputs.ecr-uri-prod }}" ]; then
            ECR_URI_PROD="${{ steps.lambda-config.outputs.ecr-uri-prod }}"
            FULL_IMAGE_URI_PROD="${ECR_URI_PROD}:${IMAGE_TAG}"
            echo "Creating multi-architecture manifest list for production ECR..."
            set +e
            PROD_OUTPUT=$(docker buildx imagetools create \
              --tag "$FULL_IMAGE_URI_PROD" \
              "${ECR_URI_PROD}:${IMAGE_TAG}-amd64" \
              "${ECR_URI_PROD}:${IMAGE_TAG}-arm64" 2>&1)
            PROD_EXIT_CODE=$?
            set -e
            
            if [ $PROD_EXIT_CODE -eq 0 ]; then
              echo "‚úÖ Production multi-arch manifest created: $FULL_IMAGE_URI_PROD"
            elif echo "$PROD_OUTPUT" | grep -q "already exists\|immutable\|cannot be overwritten"; then
              echo "‚ö†Ô∏è  Production manifest list already exists for $FULL_IMAGE_URI_PROD. Using existing manifest."
            else
              echo "‚ö†Ô∏è  Warning: Failed to create production manifest list: $PROD_OUTPUT"
              echo "Continuing with deployment..."
            fi
          fi
          
          echo ""
          echo "‚ÑπÔ∏è  Lambda functions will use architecture-specific tags (-amd64 or -arm64)"
          echo "   The multi-arch manifest is available for general Docker use"

      - name: Output image details
        run: |
          echo "‚úÖ Successfully built and pushed image for: ${{ steps.lambda-config.outputs.lambda-name }}"
          echo "üì¶ ECR Repository: ${{ steps.lambda-config.outputs.ecr-uri }}"
          echo "üè∑Ô∏è  Tag: ${{ steps.lambda-config.outputs.image-tag }}"
          echo "üîó Full Image URI: ${{ steps.lambda-config.outputs.ecr-uri }}:${{ steps.lambda-config.outputs.image-tag }}"

  deploy-dev:
    needs: [determine-environment, detect-changes, build-and-push]
    # Deploy to dev based on branch strategy
    if: success() && needs.detect-changes.outputs.folders != '' && needs.determine-environment.outputs.should-deploy-dev == 'true'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        folder: ${{ fromJson(needs.detect-changes.outputs.folders-json) }}
      fail-fast: false
    environment:
      name: dev
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Load Lambda Configuration for Deployment
        id: lambda-config
        run: |
          MAP_FILE="${{ env.MAP_FILE }}"
          FOLDER_NAME="${{ matrix.folder }}"
          ENVIRONMENT="dev"
          AWS_REGION="${{ needs.determine-environment.outputs.aws-region }}"
          COMMIT_SHA="${{ github.sha }}"
          
          # Load function config
          FUNCTION=$(jq -r ".lambda_functions[] | select(.folder_name == \"$FOLDER_NAME\")" "$MAP_FILE")
          FUNCTION_NUMBER=$(echo "$FUNCTION" | jq -r '.function_number')
          ECR_REF=$(echo "$FUNCTION" | jq -r ".ecr_repository_ref.$ENVIRONMENT")
          
          # Load environment config
          ENV_CONFIG=$(jq -r ".aws_base_config.environments.$ENVIRONMENT" "$MAP_FILE")
          ACCOUNT_ID=$(echo "$ENV_CONFIG" | jq -r '.account_id')
          ENV_PREFIX=$(echo "$ENV_CONFIG" | jq -r '.env_prefix')
          
          # Get ECR repository name
          ECR_REPO_NAME=$(jq -r ".ecr_config.repositories.$ECR_REF.name" "$MAP_FILE")
          
          # Construct OIDC ARN
          OIDC_ROLE_NAME=$(jq -r '.oidc_config.role_name' "$MAP_FILE")
          OIDC_ARN="arn:aws:iam::${ACCOUNT_ID}:role/${OIDC_ROLE_NAME}"
          
          # Construct Lambda name and ARN
          LAMBDA_NAME="${ENV_PREFIX}-${AWS_REGION}-lambda-${FUNCTION_NUMBER}"
          LAMBDA_ARN="arn:aws:lambda:${AWS_REGION}:${ACCOUNT_ID}:function:${LAMBDA_NAME}"
          
          # Construct ECR URI and image tag
          ECR_URI="${ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPO_NAME}"
          IMAGE_TAG="${LAMBDA_NAME}-${COMMIT_SHA}"
          IMAGE_URI="${ECR_URI}:${IMAGE_TAG}"
          
          echo "oidc-arn=$OIDC_ARN" >> $GITHUB_OUTPUT
          echo "lambda-name=$LAMBDA_NAME" >> $GITHUB_OUTPUT
          echo "lambda-arn=$LAMBDA_ARN" >> $GITHUB_OUTPUT
          echo "ecr-uri=$ECR_URI" >> $GITHUB_OUTPUT
          echo "image-uri=$IMAGE_URI" >> $GITHUB_OUTPUT
          echo "account-id=$ACCOUNT_ID" >> $GITHUB_OUTPUT
          
          echo "‚úÖ Deployment Configuration:"
          echo "  Lambda Name: $LAMBDA_NAME"
          echo "  Lambda ARN: $LAMBDA_ARN"
          echo "  Image URI: $IMAGE_URI"
          echo "  Account ID: $ACCOUNT_ID"

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ steps.lambda-config.outputs.oidc-arn }}
          role-session-name: GitHubActions-Dev-${{ github.run_id }}
          aws-region: ${{ needs.determine-environment.outputs.aws-region }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Deploy ${{ steps.lambda-config.outputs.lambda-name }} to Dev
        run: |
          LAMBDA_NAME="${{ steps.lambda-config.outputs.lambda-name }}"
          BASE_IMAGE_URI="${{ steps.lambda-config.outputs.image-uri }}"
          AWS_REGION="${{ needs.determine-environment.outputs.aws-region }}"
          
          echo "üöÄ Deploying $LAMBDA_NAME to dev environment..."
          
          # Get Lambda function architecture
          echo "üîç Checking Lambda function architecture..."
          LAMBDA_ARCH=$(aws lambda get-function-configuration \
            --function-name "$LAMBDA_NAME" \
            --region "$AWS_REGION" \
            --query 'Architectures[0]' \
            --output text 2>/dev/null || echo "x86_64")
          
          # Map Lambda architecture to Docker platform tag
          if [ "$LAMBDA_ARCH" == "arm64" ]; then
            ARCH_TAG="arm64"
            echo "üèóÔ∏è  Lambda uses ARM64 architecture - using ARM64 image"
          else
            ARCH_TAG="amd64"
            echo "üèóÔ∏è  Lambda uses x86_64 architecture - using AMD64 image"
          fi
          
          # Construct architecture-specific image URI
          IMAGE_URI="${BASE_IMAGE_URI}-${ARCH_TAG}"
          
          echo "üì¶ Base Image URI: $BASE_IMAGE_URI"
          echo "üì¶ Lambda Architecture: $LAMBDA_ARCH"
          echo "üì¶ Architecture Tag: $ARCH_TAG"
          echo "üì¶ Final Image URI: $IMAGE_URI"
          
          # List available Lambda functions for debugging
          echo "üìã Listing available Lambda functions in region $AWS_REGION..."
          aws lambda list-functions \
            --region "$AWS_REGION" \
            --query 'Functions[].FunctionName' \
            --output table || echo "‚ö†Ô∏è Could not list functions (may be a permissions issue)"
          
          # Check if function exists
          echo "üîç Checking if function $LAMBDA_NAME exists..."
          FUNCTION_EXISTS=$(aws lambda get-function \
            --function-name "$LAMBDA_NAME" \
            --region "$AWS_REGION" \
            --query 'Configuration.FunctionName' \
            --output text 2>/dev/null || echo "")
          
          if [ -z "$FUNCTION_EXISTS" ]; then
            echo "‚ùå ERROR: Function $LAMBDA_NAME not found!"
            echo "üìã Available functions matching pattern:"
            aws lambda list-functions \
              --region "$AWS_REGION" \
              --query "Functions[?contains(FunctionName, 'dev') || contains(FunctionName, 'lambda')].FunctionName" \
              --output table || echo "Could not list functions"
            echo ""
            echo "üí° Possible issues:"
            echo "   1. Function name doesn't match expected pattern: $LAMBDA_NAME"
            echo "   2. Function exists in a different AWS account"
            echo "   3. Function exists in a different region"
            echo "   4. OIDC role doesn't have permissions to access the function"
            exit 1
          fi
          
          echo "‚úÖ Function found: $FUNCTION_EXISTS"
          
          # Wait for any in-progress updates to complete
          echo "Checking for in-progress updates..."
          MAX_WAIT=300  # 5 minutes max wait
          WAIT_TIME=0
          while [ $WAIT_TIME -lt $MAX_WAIT ]; do
            STATE=$(aws lambda get-function-configuration \
              --function-name "$LAMBDA_NAME" \
              --region "$AWS_REGION" \
              --query 'State' --output text 2>/dev/null || echo "Active")
            if [ "$STATE" == "Active" ] || [ "$STATE" == "Inactive" ]; then
              echo "Function is ready for update (State: $STATE)"
              break
            else
              echo "Function state: $STATE, waiting 10 seconds..."
              sleep 10
              WAIT_TIME=$((WAIT_TIME + 10))
            fi
          done
          
          # Update existing Lambda function (functions already exist)
          echo "Updating Lambda function: $LAMBDA_NAME"
          MAX_RETRIES=3
          RETRY_COUNT=0
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            if aws lambda update-function-code \
              --function-name "$LAMBDA_NAME" \
              --image-uri "$IMAGE_URI" \
              --region "$AWS_REGION" 2>&1; then
              echo "Update initiated successfully"
              break
            else
              ERROR_OUTPUT=$(aws lambda update-function-code \
                --function-name "$LAMBDA_NAME" \
                --image-uri "$IMAGE_URI" \
                --region "$AWS_REGION" 2>&1 || true)
              echo "Error details: $ERROR_OUTPUT"
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "Update failed, retrying in 15 seconds... (Attempt $RETRY_COUNT/$MAX_RETRIES)"
                sleep 15
              else
                echo "‚ùå Failed to update after $MAX_RETRIES attempts"
                exit 1
              fi
            fi
          done
          
          # Wait for update to complete
          echo "Waiting for update to complete..."
          aws lambda wait function-updated \
            --function-name "$LAMBDA_NAME" \
            --region "$AWS_REGION"
          
          echo "‚úÖ Successfully deployed $LAMBDA_NAME to dev"

  approve-staging:
    needs: [determine-environment, detect-changes, build-and-push]
    # Approval required for staging based on branch strategy
    if: success() && needs.detect-changes.outputs.folders != '' && needs.determine-environment.outputs.should-deploy-staging == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: write
      pull-requests: write
    steps:
      - name: Manual Approval for Staging
        id: approval
        uses: trstringer/manual-approval@v1
        with:
          secret: ${{ secrets.GITHUB_TOKEN }}
          approvers: ${{ github.actor }}  # Approver is the person who triggered the workflow
          minimum-approvals: 1
          issue-title: "üöÄ Staging Deployment Approval Required - ${{ github.sha }}"
          issue-body: |
            ## Staging Deployment Approval
            
            **Commit:** ${{ github.sha }}
            **Author:** ${{ github.actor }}
            **Branch:** ${{ github.ref_name }} (${{ needs.determine-environment.outputs.branch-type }})
            **Environment:** ${{ needs.determine-environment.outputs.environment }}
            **Changed Folders:** ${{ needs.detect-changes.outputs.folders }}
            
            Please review and approve this staging deployment.
            
            **To approve:** Comment `/approve` on this issue
            **To reject:** Comment `/reject` on this issue
            
            This deployment will update the following Lambda functions in **staging**:
            - `stg-us-east-1-lambda-1` (from lambda-function-1)
            - `stg-us-east-1-lambda-2` (from lambda-function-2)
            - (and other changed functions)
            
            **Note:** Lambda function names follow the pattern: `stg-{region}-lambda-{number}`

      - name: Install jq for JSON parsing
        if: env.APPROVAL_EMAILS_STAGING != ''
        run: |
          sudo apt-get update
          sudo apt-get install -y jq curl

      - name: Send Email Notification for Staging Approval
        if: env.APPROVAL_EMAILS_STAGING != ''
        run: |
          echo "üìß Sending email notifications for staging approval..."
          
          # Set GitHub token for authentication
          export GITHUB_TOKEN="${{ secrets.GITHUB_TOKEN }}"
          
          # Get the issue URL (the approval action creates an issue)
          # Try to get the latest open issue (should be the approval issue)
          ISSUE_URL="https://github.com/${{ github.repository }}/issues"
          
          # Get the latest issue number (approval issue) using GitHub API directly
          ISSUE_NUMBER=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/issues?state=open&per_page=1" | \
            jq -r '.[0].number // empty' 2>/dev/null || echo "")
          
          if [ -n "$ISSUE_NUMBER" ] && [ "$ISSUE_NUMBER" != "null" ]; then
            ISSUE_URL="https://github.com/${{ github.repository }}/issues/${ISSUE_NUMBER}"
            echo "‚úÖ Found approval issue: ${ISSUE_URL}"
          else
            echo "‚ö†Ô∏è Could not find issue number, using general issues URL"
          fi
          
          # Prepare email content
          SUBJECT="üöÄ Staging Deployment Approval Required - ${{ github.ref_name }}"
          BODY="A staging deployment approval is required for commit ${{ github.sha }}.
          
          Branch: ${{ github.ref_name }}
          Author: ${{ github.actor }}
          Changed Functions: ${{ needs.detect-changes.outputs.folders }}
          
          Please review and approve the deployment:
          ${ISSUE_URL}
          
          To approve: Comment '/approve' on the issue
          To reject: Comment '/reject' on the issue
          
          Repository: ${{ github.repository }}
          Workflow: ${{ github.workflow }}
          Run ID: ${{ github.run_id }}"
          
          # Send emails using AWS SES (if configured) or other email service
          if [ -n "${{ secrets.AWS_SES_REGION }}" ] && [ -n "${{ secrets.AWS_SES_FROM_EMAIL }}" ]; then
            echo "Using AWS SES to send emails..."
            # Configure AWS credentials for SES
            export AWS_ACCESS_KEY_ID="${{ secrets.AWS_ACCESS_KEY_ID }}"
            export AWS_SECRET_ACCESS_KEY="${{ secrets.AWS_SECRET_ACCESS_KEY }}"
            export AWS_DEFAULT_REGION="${{ secrets.AWS_SES_REGION }}"
            
            # Send email to each recipient
            IFS=',' read -ra EMAILS <<< "${{ env.APPROVAL_EMAILS_STAGING }}"
            for email in "${EMAILS[@]}"; do
              email=$(echo "$email" | xargs)  # Trim whitespace
              if [ -n "$email" ]; then
                echo "Sending email to: $email"
                aws ses send-email \
                  --from "${{ secrets.AWS_SES_FROM_EMAIL }}" \
                  --to "$email" \
                  --subject "$SUBJECT" \
                  --text "$BODY" 2>&1 || echo "‚ö†Ô∏è Failed to send email to $email"
              fi
            done
          else
            echo "‚ö†Ô∏è Email service not configured. Please set AWS_SES_REGION and AWS_SES_FROM_EMAIL secrets."
            echo "üìã Approval Issue URL: ${ISSUE_URL}"
            echo "üìß Recipients: ${{ env.APPROVAL_EMAILS_STAGING }}"
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        continue-on-error: true

  deploy-staging:
    needs: [determine-environment, detect-changes, build-and-push, approve-staging]
    # Deploy to staging based on branch strategy after approval
    if: success() && needs.detect-changes.outputs.folders != '' && needs.determine-environment.outputs.should-deploy-staging == 'true'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        folder: ${{ fromJson(needs.detect-changes.outputs.folders-json) }}
      fail-fast: false
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Load Lambda Configuration for Deployment
        id: lambda-config
        run: |
          MAP_FILE="${{ env.MAP_FILE }}"
          FOLDER_NAME="${{ matrix.folder }}"
          ENVIRONMENT="staging"
          AWS_REGION="${{ needs.determine-environment.outputs.aws-region }}"
          COMMIT_SHA="${{ github.sha }}"
          
          # Load function config
          FUNCTION=$(jq -r ".lambda_functions[] | select(.folder_name == \"$FOLDER_NAME\")" "$MAP_FILE")
          FUNCTION_NUMBER=$(echo "$FUNCTION" | jq -r '.function_number')
          ECR_REF=$(echo "$FUNCTION" | jq -r ".ecr_repository_ref.$ENVIRONMENT")
          
          # Load environment config
          ENV_CONFIG=$(jq -r ".aws_base_config.environments.$ENVIRONMENT" "$MAP_FILE")
          ACCOUNT_ID=$(echo "$ENV_CONFIG" | jq -r '.account_id')
          ENV_PREFIX=$(echo "$ENV_CONFIG" | jq -r '.env_prefix')
          
          # Get ECR repository name
          ECR_REPO_NAME=$(jq -r ".ecr_config.repositories.$ECR_REF.name" "$MAP_FILE")
          
          # Construct OIDC ARN
          OIDC_ROLE_NAME=$(jq -r '.oidc_config.role_name' "$MAP_FILE")
          OIDC_ARN="arn:aws:iam::${ACCOUNT_ID}:role/${OIDC_ROLE_NAME}"
          
          # Construct Lambda name and ARN
          LAMBDA_NAME="${ENV_PREFIX}-${AWS_REGION}-lambda-${FUNCTION_NUMBER}"
          LAMBDA_ARN="arn:aws:lambda:${AWS_REGION}:${ACCOUNT_ID}:function:${LAMBDA_NAME}"
          
          # Construct ECR URI and image tag
          ECR_URI="${ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPO_NAME}"
          IMAGE_TAG="${LAMBDA_NAME}-${COMMIT_SHA}"
          IMAGE_URI="${ECR_URI}:${IMAGE_TAG}"
          
          echo "oidc-arn=$OIDC_ARN" >> $GITHUB_OUTPUT
          echo "lambda-name=$LAMBDA_NAME" >> $GITHUB_OUTPUT
          echo "lambda-arn=$LAMBDA_ARN" >> $GITHUB_OUTPUT
          echo "ecr-uri=$ECR_URI" >> $GITHUB_OUTPUT
          echo "image-uri=$IMAGE_URI" >> $GITHUB_OUTPUT
          echo "account-id=$ACCOUNT_ID" >> $GITHUB_OUTPUT
          
          echo "‚úÖ Deployment Configuration:"
          echo "  Lambda Name: $LAMBDA_NAME"
          echo "  Lambda ARN: $LAMBDA_ARN"
          echo "  Image URI: $IMAGE_URI"
          echo "  Account ID: $ACCOUNT_ID"

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ steps.lambda-config.outputs.oidc-arn }}
          role-session-name: GitHubActions-Staging-${{ github.run_id }}
          aws-region: ${{ needs.determine-environment.outputs.aws-region }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Deploy ${{ steps.lambda-config.outputs.lambda-name }} to Staging
        run: |
          LAMBDA_NAME="${{ steps.lambda-config.outputs.lambda-name }}"
          BASE_IMAGE_URI="${{ steps.lambda-config.outputs.image-uri }}"
          AWS_REGION="${{ needs.determine-environment.outputs.aws-region }}"
          
          echo "üöÄ Deploying $LAMBDA_NAME to staging environment..."
          
          # Get Lambda function architecture
          echo "üîç Checking Lambda function architecture..."
          LAMBDA_ARCH=$(aws lambda get-function-configuration \
            --function-name "$LAMBDA_NAME" \
            --region "$AWS_REGION" \
            --query 'Architectures[0]' \
            --output text 2>/dev/null || echo "x86_64")
          
          # Map Lambda architecture to Docker platform tag
          if [ "$LAMBDA_ARCH" == "arm64" ]; then
            ARCH_TAG="arm64"
            echo "üèóÔ∏è  Lambda uses ARM64 architecture - using ARM64 image"
          else
            ARCH_TAG="amd64"
            echo "üèóÔ∏è  Lambda uses x86_64 architecture - using AMD64 image"
          fi
          
          # Construct architecture-specific image URI
          IMAGE_URI="${BASE_IMAGE_URI}-${ARCH_TAG}"
          
          echo "üì¶ Base Image URI: $BASE_IMAGE_URI"
          echo "üì¶ Lambda Architecture: $LAMBDA_ARCH"
          echo "üì¶ Architecture Tag: $ARCH_TAG"
          echo "üì¶ Final Image URI: $IMAGE_URI"
          
          # Wait for any in-progress updates to complete
          echo "Checking for in-progress updates..."
          MAX_WAIT=300  # 5 minutes max wait
          WAIT_TIME=0
          while [ $WAIT_TIME -lt $MAX_WAIT ]; do
            STATE=$(aws lambda get-function-configuration \
              --function-name "$LAMBDA_NAME" \
              --region "$AWS_REGION" \
              --query 'State' --output text 2>/dev/null || echo "Active")
            if [ "$STATE" == "Active" ] || [ "$STATE" == "Inactive" ]; then
              echo "Function is ready for update (State: $STATE)"
              break
            else
              echo "Function state: $STATE, waiting 10 seconds..."
              sleep 10
              WAIT_TIME=$((WAIT_TIME + 10))
            fi
          done
          
          # Update existing Lambda function (functions already exist)
          echo "Updating Lambda function: $LAMBDA_NAME"
          MAX_RETRIES=3
          RETRY_COUNT=0
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            if aws lambda update-function-code \
              --function-name "$LAMBDA_NAME" \
              --image-uri "$IMAGE_URI" \
              --region "$AWS_REGION" 2>&1; then
              echo "Update initiated successfully"
              break
            else
              ERROR_OUTPUT=$(aws lambda update-function-code \
                --function-name "$LAMBDA_NAME" \
                --image-uri "$IMAGE_URI" \
                --region "$AWS_REGION" 2>&1 || true)
              echo "Error details: $ERROR_OUTPUT"
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "Update failed, retrying in 15 seconds... (Attempt $RETRY_COUNT/$MAX_RETRIES)"
                sleep 15
              else
                echo "‚ùå Failed to update after $MAX_RETRIES attempts"
                exit 1
              fi
            fi
          done
          
          # Wait for update to complete
          echo "Waiting for update to complete..."
          aws lambda wait function-updated \
            --function-name "$LAMBDA_NAME" \
            --region "$AWS_REGION"
          
          echo "‚úÖ Successfully deployed $LAMBDA_NAME to staging"

  approve-production:
    needs: [determine-environment, detect-changes, build-and-push]
    # Approval required for production based on branch strategy
    # Production approval is independent and can proceed separately from staging
    if: success() && needs.detect-changes.outputs.folders != '' && needs.determine-environment.outputs.should-deploy-prod == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: write
      pull-requests: write
    steps:
      - name: Manual Approval for Production
        id: approval
        uses: trstringer/manual-approval@v1
        with:
          secret: ${{ secrets.GITHUB_TOKEN }}
          approvers: ${{ github.actor }}  # Approver is the person who triggered the workflow
          minimum-approvals: 1
          issue-title: "üöÄ Production Deployment Approval Required - ${{ github.sha }}"
          issue-body: |
            ## Production Deployment Approval
            
            **‚ö†Ô∏è WARNING: This is a PRODUCTION deployment! ‚ö†Ô∏è**
            
            **Commit:** ${{ github.sha }}
            **Author:** ${{ github.actor }}
            **Branch:** ${{ github.ref_name }} (${{ needs.determine-environment.outputs.branch-type }})
            **Environment:** ${{ needs.determine-environment.outputs.environment }}
            **Changed Folders:** ${{ needs.detect-changes.outputs.folders }}
            
            Please carefully review and approve this production deployment.
            
            **To approve:** Comment `/approve` on this issue
            **To reject:** Comment `/reject` on this issue
            
            This deployment will update the following Lambda functions in **PRODUCTION**:
            - `prd-us-east-1-lambda-1` (from lambda-function-1)
            - `prd-us-east-1-lambda-2` (from lambda-function-2)
            - (and other changed functions)
            
            **Note:** Lambda function names follow the pattern: `prd-{region}-lambda-{number}`
            
            **‚ÑπÔ∏è Independent Deployment:** Production deployment uses a separate ECR repository and can proceed independently of staging deployment.

      - name: Install jq for JSON parsing
        if: env.APPROVAL_EMAILS_PRODUCTION != ''
        run: |
          sudo apt-get update
          sudo apt-get install -y jq curl

      - name: Send Email Notification for Production Approval
        if: env.APPROVAL_EMAILS_PRODUCTION != ''
        run: |
          echo "üìß Sending email notifications for production approval..."
          
          # Set GitHub token for authentication
          export GITHUB_TOKEN="${{ secrets.GITHUB_TOKEN }}"
          
          # Get the issue URL (the approval action creates an issue)
          # Try to get the latest open issue (should be the approval issue)
          ISSUE_URL="https://github.com/${{ github.repository }}/issues"
          
          # Get the latest issue number (approval issue) using GitHub API directly
          ISSUE_NUMBER=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/issues?state=open&per_page=1" | \
            jq -r '.[0].number // empty' 2>/dev/null || echo "")
          
          if [ -n "$ISSUE_NUMBER" ] && [ "$ISSUE_NUMBER" != "null" ]; then
            ISSUE_URL="https://github.com/${{ github.repository }}/issues/${ISSUE_NUMBER}"
            echo "‚úÖ Found approval issue: ${ISSUE_URL}"
          else
            echo "‚ö†Ô∏è Could not find issue number, using general issues URL"
          fi
          
          # Prepare email content
          SUBJECT="üöÄ PRODUCTION Deployment Approval Required - ${{ github.ref_name }}"
          BODY="‚ö†Ô∏è URGENT: A PRODUCTION deployment approval is required for commit ${{ github.sha }}.
          
          Branch: ${{ github.ref_name }}
          Author: ${{ github.actor }}
          Changed Functions: ${{ needs.detect-changes.outputs.folders }}
          
          This is a PRODUCTION deployment. Please review carefully and approve:
          ${ISSUE_URL}
          
          To approve: Comment '/approve' on the issue
          To reject: Comment '/reject' on the issue
          
          Repository: ${{ github.repository }}
          Workflow: ${{ github.workflow }}
          Run ID: ${{ github.run_id }}"
          
          # Send emails using AWS SES (if configured) or other email service
          if [ -n "${{ secrets.AWS_SES_REGION }}" ] && [ -n "${{ secrets.AWS_SES_FROM_EMAIL }}" ]; then
            echo "Using AWS SES to send emails..."
            # Configure AWS credentials for SES
            export AWS_ACCESS_KEY_ID="${{ secrets.AWS_ACCESS_KEY_ID }}"
            export AWS_SECRET_ACCESS_KEY="${{ secrets.AWS_SECRET_ACCESS_KEY }}"
            export AWS_DEFAULT_REGION="${{ secrets.AWS_SES_REGION }}"
            
            # Send email to each recipient
            IFS=',' read -ra EMAILS <<< "${{ env.APPROVAL_EMAILS_PRODUCTION }}"
            for email in "${EMAILS[@]}"; do
              email=$(echo "$email" | xargs)  # Trim whitespace
              if [ -n "$email" ]; then
                echo "Sending email to: $email"
                aws ses send-email \
                  --from "${{ secrets.AWS_SES_FROM_EMAIL }}" \
                  --to "$email" \
                  --subject "$SUBJECT" \
                  --text "$BODY" 2>&1 || echo "‚ö†Ô∏è Failed to send email to $email"
              fi
            done
          else
            echo "‚ö†Ô∏è Email service not configured. Please set AWS_SES_REGION and AWS_SES_FROM_EMAIL secrets."
            echo "üìã Approval Issue URL: ${ISSUE_URL}"
            echo "üìß Recipients: ${{ env.APPROVAL_EMAILS_PRODUCTION }}"
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        continue-on-error: true

  deploy-prod:
    needs: [determine-environment, detect-changes, build-and-push, approve-production]
    # Deploy to production based on branch strategy after approval
    # Production deployment is independent and uses its own ECR repository
    if: success() && needs.detect-changes.outputs.folders != '' && needs.determine-environment.outputs.should-deploy-prod == 'true'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        folder: ${{ fromJson(needs.detect-changes.outputs.folders-json) }}
      fail-fast: false
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Load Lambda Configuration for Deployment
        id: lambda-config
        run: |
          MAP_FILE="${{ env.MAP_FILE }}"
          FOLDER_NAME="${{ matrix.folder }}"
          ENVIRONMENT="prod"
          AWS_REGION="${{ needs.determine-environment.outputs.aws-region }}"
          COMMIT_SHA="${{ github.sha }}"
          
          # Load function config
          FUNCTION=$(jq -r ".lambda_functions[] | select(.folder_name == \"$FOLDER_NAME\")" "$MAP_FILE")
          FUNCTION_NUMBER=$(echo "$FUNCTION" | jq -r '.function_number')
          ECR_REF=$(echo "$FUNCTION" | jq -r ".ecr_repository_ref.$ENVIRONMENT")
          
          # Load environment config
          ENV_CONFIG=$(jq -r ".aws_base_config.environments.$ENVIRONMENT" "$MAP_FILE")
          ACCOUNT_ID=$(echo "$ENV_CONFIG" | jq -r '.account_id')
          ENV_PREFIX=$(echo "$ENV_CONFIG" | jq -r '.env_prefix')
          
          # Get ECR repository name (prod uses production repo)
          ECR_REF_PROD=$(echo "$FUNCTION" | jq -r ".ecr_repository_ref.prod")
          ECR_REPO_NAME=$(jq -r ".ecr_config.repositories.$ECR_REF_PROD.name" "$MAP_FILE")
          
          # Construct OIDC ARN
          OIDC_ROLE_NAME=$(jq -r '.oidc_config.role_name' "$MAP_FILE")
          OIDC_ARN="arn:aws:iam::${ACCOUNT_ID}:role/${OIDC_ROLE_NAME}"
          
          # Construct Lambda name and ARN (prod uses prd prefix)
          LAMBDA_NAME="${ENV_PREFIX}-${AWS_REGION}-lambda-${FUNCTION_NUMBER}"
          LAMBDA_ARN="arn:aws:lambda:${AWS_REGION}:${ACCOUNT_ID}:function:${LAMBDA_NAME}"
          
          # Construct ECR URI and image tag (using production repo and production tag)
          ECR_URI="${ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPO_NAME}"
          IMAGE_TAG="${LAMBDA_NAME}-${COMMIT_SHA}"
          IMAGE_URI="${ECR_URI}:${IMAGE_TAG}"
          
          echo "oidc-arn=$OIDC_ARN" >> $GITHUB_OUTPUT
          echo "lambda-name=$LAMBDA_NAME" >> $GITHUB_OUTPUT
          echo "lambda-arn=$LAMBDA_ARN" >> $GITHUB_OUTPUT
          echo "ecr-uri=$ECR_URI" >> $GITHUB_OUTPUT
          echo "image-uri=$IMAGE_URI" >> $GITHUB_OUTPUT
          echo "account-id=$ACCOUNT_ID" >> $GITHUB_OUTPUT
          
          echo "‚úÖ Deployment Configuration:"
          echo "  Lambda Name: $LAMBDA_NAME"
          echo "  Lambda ARN: $LAMBDA_ARN"
          echo "  Image URI: $IMAGE_URI (from production repo)"
          echo "  Account ID: $ACCOUNT_ID"

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ steps.lambda-config.outputs.oidc-arn }}
          role-session-name: GitHubActions-Prod-${{ github.run_id }}
          aws-region: ${{ needs.determine-environment.outputs.aws-region }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Deploy ${{ steps.lambda-config.outputs.lambda-name }} to Production
        run: |
          LAMBDA_NAME="${{ steps.lambda-config.outputs.lambda-name }}"
          BASE_IMAGE_URI="${{ steps.lambda-config.outputs.image-uri }}"
          AWS_REGION="${{ needs.determine-environment.outputs.aws-region }}"
          
          # Get Lambda function architecture
          echo "üîç Checking Lambda function architecture..."
          LAMBDA_ARCH=$(aws lambda get-function-configuration \
            --function-name "$LAMBDA_NAME" \
            --region "$AWS_REGION" \
            --query 'Architectures[0]' \
            --output text 2>/dev/null || echo "x86_64")
          
          # Map Lambda architecture to Docker platform tag
          if [ "$LAMBDA_ARCH" == "arm64" ]; then
            ARCH_TAG="arm64"
            echo "üèóÔ∏è  Lambda uses ARM64 architecture - using ARM64 image"
          else
            ARCH_TAG="amd64"
            echo "üèóÔ∏è  Lambda uses x86_64 architecture - using AMD64 image"
          fi
          
          # Construct architecture-specific image URI
          IMAGE_URI="${BASE_IMAGE_URI}-${ARCH_TAG}"
          
          echo "üì¶ Base Image URI: $BASE_IMAGE_URI"
          echo "üì¶ Lambda Architecture: $LAMBDA_ARCH"
          echo "üì¶ Architecture Tag: $ARCH_TAG"
          echo "üì¶ Final Image URI: $IMAGE_URI"
          
          echo "üöÄ Deploying $LAMBDA_NAME to production environment..."
          
          # Wait for any in-progress updates to complete
          echo "Checking for in-progress updates..."
          MAX_WAIT=300  # 5 minutes max wait
          WAIT_TIME=0
          while [ $WAIT_TIME -lt $MAX_WAIT ]; do
            STATE=$(aws lambda get-function-configuration \
              --function-name "$LAMBDA_NAME" \
              --region "$AWS_REGION" \
              --query 'State' --output text 2>/dev/null || echo "Active")
            if [ "$STATE" == "Active" ] || [ "$STATE" == "Inactive" ]; then
              echo "Function is ready for update (State: $STATE)"
              break
            else
              echo "Function state: $STATE, waiting 10 seconds..."
              sleep 10
              WAIT_TIME=$((WAIT_TIME + 10))
            fi
          done
          
          # Update existing Lambda function (functions already exist)
          echo "Updating Lambda function: $LAMBDA_NAME"
          MAX_RETRIES=5
          RETRY_COUNT=0
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            if aws lambda update-function-code \
              --function-name "$LAMBDA_NAME" \
              --image-uri "$IMAGE_URI" \
              --region "$AWS_REGION" 2>&1; then
              echo "Update initiated successfully"
              break
            else
              ERROR_OUTPUT=$(aws lambda update-function-code \
                --function-name "$LAMBDA_NAME" \
                --image-uri "$IMAGE_URI" \
                --region "$AWS_REGION" 2>&1 || true)
              echo "Error details: $ERROR_OUTPUT"
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "Update failed, retrying in 15 seconds... (Attempt $RETRY_COUNT/$MAX_RETRIES)"
                sleep 15
              else
                echo "‚ùå Failed to update after $MAX_RETRIES attempts"
                exit 1
              fi
            fi
          done
          
          # Wait for update to complete
          echo "Waiting for update to complete..."
          aws lambda wait function-updated \
            --function-name "$LAMBDA_NAME" \
            --region "$AWS_REGION"
          
          echo "‚úÖ Successfully deployed $LAMBDA_NAME to production"

  merge-release-to-main:
    needs: [determine-environment, deploy-prod]
    # Only merge after successful production deployment on release branch
    if: success() && needs.determine-environment.outputs.should-deploy-prod == 'true' && github.ref == 'refs/heads/release'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure Git
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      - name: Merge release to main
        run: |
          echo "üîÑ Merging release branch to main after successful production deployment..."
          
          # Fetch all branches
          git fetch origin
          
          # Checkout main branch
          git checkout main
          git pull origin main
          
          # Merge release into main
          if git merge origin/release --no-edit; then
            echo "‚úÖ Successfully merged release into main"
            
            # Push to main
            if git push origin main; then
              echo "‚úÖ Successfully pushed merged changes to main"
            else
              echo "‚ùå Failed to push to main"
              exit 1
            fi
          else
            echo "‚ö†Ô∏è Merge conflict or merge failed. Please merge manually."
            echo "Release branch: release"
            echo "Main branch: main"
            exit 1
          fi
          
          echo "üéâ Release branch successfully merged to main!"

